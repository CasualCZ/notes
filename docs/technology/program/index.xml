<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on CC Notes</title>
    <link>https://cctrip.github.io/notes/docs/technology/program/</link>
    <description>Recent content in 编程 on CC Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://cctrip.github.io/notes/docs/technology/program/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Advanced/Algorithm/algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Advanced/Algorithm/algorithm/</guid>
      <description>算法 #   冒泡排序  对于一个无序的序列，每次对比两个相邻数的大小，若第i个数大于第i+1个数，两个数进行位置互换。每组排序可以选出一个最大的数，然后继续从第一个数开始进行对比，直到完成排序
#伪代码 int num[] for(int i=0; i &amp;lt; num.length-1; i++){ for(int j=0; j &amp;lt; num.length-i-1; j++){ if( num[j] &amp;gt; num[j+1] ){ int temp = num[j] num[j+1] = num[j] num[j] = temp } } }   选择排序  对于一个无序的序列，从第一个数开始，每次跟接下去的数对比，若第1个数小于第i个数，两个数位置互换，每次选出最小的数，然后开始对比第二个数，直到完成排序。
#伪代码 int num[] for(int i=0; i &amp;lt; num.length-1; i++){ for(int j=i+1; j &amp;lt; num.length-1; j++){ if( num[i] &amp;gt; num[j] ){ int temp = num[i] num[i] = num[j] num[j] = temp } } }   归并排序  对于一个无序的序列，将序列用递归的方式划分成左右两个序列，然后依次排序合并序列。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Advanced/DataStructure/datastructure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Advanced/DataStructure/datastructure/</guid>
      <description>数据结构 #    链表
  堆栈
  队列
  哈希表
  二叉排序树
  单词查找树
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Advanced/Design/factoryMethod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Advanced/Design/factoryMethod/</guid>
      <description>工厂方法模式(Factory Method Pattern) #  模式定义 #  工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
 模式结构 #    Product：抽象产品
  ConcreteProduct：具体产品
  Factory：抽象工厂
  ConcreteFactory：具体工厂
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Advanced/Design/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Advanced/Design/README/</guid>
      <description>设计模式 #  设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。
 分类 #  创建型模式 #  创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。
创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。
   简单工厂模式
   工厂方法模式
   抽象工厂模式
   建造者模式
   原型模式
   单例模式
   结构型模式 #   行为型模式 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Advanced/Design/simpleFactory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Advanced/Design/simpleFactory/</guid>
      <description>简单工厂模式(Simple Factory Pattern) #  模式定义 #  简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
 模式结构 #    Factory：工厂角色
工厂角色负责实现创建所有实例的内部逻辑
  Product：抽象产品角色
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
  ConcreteProduct：具体产品角色
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Basic/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Basic/README/</guid>
      <description>编程基础 #  编程语言 #    解释型语言
 程序由解释器读取并执行 SoucreCode --&amp;gt; Interpreter --&amp;gt; Output    编译型语言
 程序被编译器翻译成机器语言后再执行 SourceCode --&amp;gt; Compliler --&amp;gt; ObjectCode --&amp;gt; Executor --&amp;gt; Output     什么是程序？ #  程序是指定如何执行计算的指令序列。
不同的编程语言具有一些共同的基础特性：
 input：从键盘，文件或者其他输入设备中获取数据。 output：在屏幕显示数据，或者将数据发送给文件或者输出设备。 math：执行基本的数学运算，比如加法和乘法。 conditional execution：检查条件并执行相应的代码。 repetition：反复执行一些操作。  编程可以视为将大型的复杂任务打破成更小和更小的子任务，直到子任务简单到足以执行上述的基本操作的过程。
 调试(debugging) #  编程容易出错。编程错误被称为错误，并且跟踪它们的过程称为调试。
 Syntax errors：语法错误(语法是指程序的结构和关于该结构的规则)。 Runtime errors(exceptions)：运行时错误(异常)。 Semantic errors：语义错误，做的不是你想要让它做的事情。  调试是通过更改程序去发现和解决错误。
 数据类型(type) #   interger：整数，例如1,2 string: 字符串，例如&amp;rsquo;Hello&amp;rsquo;   变量(variables) #  变量是引用值的名称，编程语言最强大的功能之一就是操纵变量的能力。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Python/CookBook/DataStructuresAndAlgorithms/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Python/CookBook/DataStructuresAndAlgorithms/README/</guid>
      <description>数据结构和算法 #    解压序列赋值给多个变量
问题，现在有一个包含N个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给N个变量？
实现： 详细代码
 &amp;gt;&amp;gt;&amp;gt; data = [&#39;John&#39;,170,60,(1999,9,9)] &amp;gt;&amp;gt;&amp;gt; name, height, weight, birthday = data ### 另一种方式 &amp;gt;&amp;gt;&amp;gt; name, height, weight, (year, mon, day) = data    解压可迭代对象赋值给多个变量
问题，如果一个可迭代对象的元素个数超过变量个数时，会抛出一个ValueError。那么怎样才能从这个可迭代对象中解压出N个元素出来？
实现： 详细代码
 &amp;gt;&amp;gt;&amp;gt; record = (&#39;Dave&#39;, &#39;dave@example.com&#39;, &#39;773-555-1212&#39;, &#39;847-555-1212&#39;) &amp;gt;&amp;gt;&amp;gt; name, email, *phone_numbers = record    保留最后N个元素
问题，在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？
实现： 详细代码
 &amp;gt;&amp;gt;&amp;gt; from collections import deque &amp;gt;&amp;gt;&amp;gt; q = deque(maxlen = 3) &amp;gt;&amp;gt;&amp;gt; q.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Python/CookBook/StringsAndText/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Python/CookBook/StringsAndText/README/</guid>
      <description>#字符串和文本
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Python/Framework/Django/django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Python/Framework/Django/django/</guid>
      <description>Django #  环境初始化 #  python3 install virtualenv cd demosite mkdir py3env virtualenv ./py3env/ source py3env/bin/activate #install Django pip3 install Django  项目初始化 #  django-admin startproject demosite python manage.py runserver python manage.py startapp polls  项目结构 #  demosite/ manage.py demosite/ __init__.py settings.py urls.py wsgi.py polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Python/Framework/Flask/flask/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Python/Framework/Flask/flask/</guid>
      <description>Flask #  安装 #  pip install flask   程序基本结构 #   初始化  所有 Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为 Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。
from flask import Flask app = Flask(&#39;__name__&#39;)  路由和函数  程序实例需要知道对每个URL请求运行哪些代码，所以保存了一个URL到Python函数的映射关系。处理URL和函数之间关系的程序称为路由。 在Flask程序中定义路由的最简便方式，是使用程序实例提供的app.route修饰器，把修饰的函数注册为路由。
@app.route(&#39;/&#39;) def index(): return &#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&#39;   启动服务
if name == &amp;lsquo;main&amp;rsquo; app.run(Debug=True)
   模版 #  模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。为了渲染模板，Flask 使用了一个名为 Jinja2 的强大模板引擎。
Jinja2模板引擎 #  templates/user.html：Jinja2 模板
&amp;lt;h1&amp;gt;Hello {{ name }} !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Python/Framework/Scrapy/scrapy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Python/Framework/Scrapy/scrapy/</guid>
      <description>#Scrapy Scrapy是一个快速的高级Web爬网和Web抓取框架，用于抓取网站并从其页面提取结构化数据。
安装 #  pip install scrapy scrapy startproject scrapytest   第一个爬虫 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Python/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Python/README/</guid>
      <description>Python #  基础语法 #    数据类型
  流控
  函数
  模块
   常用库 #   CookBook #     数据和算法
   字符串和文本
   框架 #     Flask
   Scrapy
   Django
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/git/</guid>
      <description>Git #  Git起步 #     Git简介
   Git安装
   Git配置
   Git基础 #     创建版本库
   记录更新
   提交历史
   撤销操作
   远程仓库
   标签
   别名
   Git分支 #   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/alias/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/alias/</guid>
      <description>别名 #  在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。
Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：
$ git config --global alias.co checkout $ git config --global alias.br branch $ git config --global alias.ci commit $ git config --global alias.st status  这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。
在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：
$ git config --global alias.unstage &#39;reset HEAD --&#39;  这会使下面的两个命令等价：
$ git unstage fileA $ git reset HEAD -- fileA  这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/commitHistory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/commitHistory/</guid>
      <description>提交历史 #  查看提交历史 #  git log 命令，查看提交历史。
$ git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit  默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。
 git log 常用选项 #  -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/configuration/</guid>
      <description>Git初始配置 #  Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
  /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 &amp;ndash;system 选项的 git config 时，它会从此文件读写配置变量。
  ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 &amp;ndash;global 选项让 Git 读写此文件。
  当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。
  每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
用户信息 #  当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：
$ git config --global user.name &amp;quot;CodeCC&amp;quot; $ git config --global user.email CodeCC@example.com  再次强调，如果使用了 &amp;ndash;global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 &amp;ndash;global 选项的命令来配置。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/createNew/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/createNew/</guid>
      <description>创建版本库 #    创建一个空目录
 $ cd /usr/local/src $ mkdir project    创建版本库
  初始化
 $ git init Initialized empty Git repository in /usr/local/src/project/.git/    克隆现有仓库
 $ git clone [url]      添加文件
 $ git add README.md $ git commit -m &#39;first commit&#39;    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/install/</guid>
      <description>Git安装 #    yum安装
 $ sudo yum install git    源码安装
依赖包安装
 $ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc xmlto docbook2x  从 https://www.kernel.org/pub/software/scm/git获取最新的版本包
编译安装
 $ tar -zxf git-2.0.0.tar.gz $ cd git-2.0.0 $ make configure $ ./configure --prefix=/usr/local/git $ make all doc info $ sudo make install install-doc install-html install-info  升级
 $ git clone git://git.kernel.org/pub/scm/git/git.git   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/introduce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/introduce/</guid>
      <description>Git简介 #  git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。
  特点
  速度
  简单的设计
  对非线性开发模式的强力支持（允许成千上万个并行开发的分支）
  完全分布式
  有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）
    三种状态[工作区域]
  已提交(commit),[Git仓库]
  已修改(modified),[工作目录]
  已暂存(staged),[暂存区域]
    基本工作流程
  在工作目录中修改文件
  暂存文件，将文件的快照放入暂存区域。
  提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。
     </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/record/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/record/</guid>
      <description>记录更新 #  记录每次更新到仓库 #    文件状态
  已跟踪文件
  未修改
  已修改
  已放入暂存区
    未跟踪文件
    使用 Git 时文件的生命周期如下：
  文件状态 #  git status 命令，用于查看哪些文件处于什么状态。
已跟踪文件未被更改过，且没有处于未跟踪状态的新文件。会看到类似这样的输出：
$ git status On branch master nothing to commit, working directory clean  存在新的未跟踪文件。会看到类似这样的输出：
$ echo &#39;My Project&#39; &amp;gt; README.md $ git status # On branch master # # Initial commit # # Untracked files: # (use &amp;quot;git add &amp;lt;file&amp;gt;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/remote/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/remote/</guid>
      <description>远程仓库 #  远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。
管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。
 查看远程仓库 #  git remote ： 列出指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin
$ git remote origin  指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。
$ git remote -v origin https://github.com/Code-CC/leetcode (fetch) origin https://github.com/Code-CC/leetcode (push)   添加远程仓库 #  运行 git remote add   添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：
$ git remote origin $ git remote add pb https://github.com/paulboone/ticgit $ git remote -v origin	https://github.com/schacon/ticgit (fetch) origin	https://github.com/schacon/ticgit (push) pb	https://github.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/tag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/tag/</guid>
      <description>打标签 #  Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。
 列出标签 #  git tag：列出已有的标签
$ git tag v0.1 v1.3  git tag -l ：使用特定的模式查找标签。
$ git tag -l &#39;v1.8.5*&#39; v1.8.5 v1.8.5-rc0 v1.8.5-rc1 v1.8.5-rc2 v1.8.5-rc3 v1.8.5.1 v1.8.5.2 v1.8.5.3 v1.8.5.4 v1.8.5.5   创建标签 #  Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。
一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。
然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。
  附注标签
git tag -a ：添加一个附注标签。
 $ git tag -a v1.4 -m &#39;my version 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/undo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/Git/undo/</guid>
      <description>撤消操作 #  重新提交 #  &amp;ndash;amend 选项的提交命令尝试重新提交：
$ git commit --amend  这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。
例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：
$ git commit -m &#39;initial commit&#39; $ git add forgotten_file $ git commit --amend  最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。
 取消暂存的文件 #  $ git add * $ git status # On branch master # Changes to be committed: # (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage) # # modified: CONTRIBUTING.md # modified: README #  git rest HEAD  取消暂存：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/RevisionControl/README/</guid>
      <description>版本控制 #  什么是“版本控制”？ #  版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。
 分类 #    本地版本控制系统
许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。
 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
  集中化的版本控制系统
接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、 Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。
 这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。
事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。
  分布式版本控制系统
于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/Shell/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/Shell/README/</guid>
      <description>Shell #  基础语法 #    变量
  函数
   进阶 #    代码风格  </description>
    </item>
    
  </channel>
</rss>