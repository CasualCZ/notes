<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Kubernetes 网络 #  集群网络系统是 Kubernetes 的核心部分，但是想要准确了解它的工作原理可是个不小的挑战。下面列出的是网络系统的的四个主要问题：
 高度耦合的容器间通信：这个已经被 pods 和 localhost 通信解决了。 Pod 间通信：这个是本文档的重点要讲述的。 Pod 和 Service 间通信：这个已经在 services 里讲述过了。 外部和 Service 间通信：这个也已经在 services 讲述过了。  Kubernetes 的宗旨就是在应用之间共享机器。通常来说，共享机器需要两个应用之间不能使用相同的端口，但是在多个应用开发者之间去大规模地协调端口是件很困难的事情，尤其是还要让用户暴露在他们控制范围之外的集群级别的问题上。
动态分配端口也会给系统带来很多复杂度 - 每个应用都需要设置一个端口的参数，而 API 服务器还需要知道如何将动态端口数值插入到配置模块中，服务也需要知道如何找到对方等等。与其去解决这些问题，Kubernetes 选择了其他不同的方法。
Kubernetes 网络模型 #  每一个 Pod 都有它自己的IP地址，这就意味着你不需要显式地在每个 Pod 之间创建链接，你几乎不需要处理容器端口到主机端口之间的映射。这将创建一个干净的、向后兼容的模型，在这个模型里，从端口分配、命名、服务发现、负载均衡、应用配置和迁移的角度来看，Pod 可以被视作虚拟机或者物理主机。
Kubernetes 对所有网络设施的实施，都需要满足以下的基本要求（除非有设置一些特定的网络分段策略）：
 节点上的 pods 可以不通过 NAT 和其他任何节点上的 pods 通信 节点上的代理（比如：系统守护进程、kubelet） 可以和节点上的所有pods通信  备注：仅针对那些支持 Pods 在主机网络中运行的平台(比如：Linux) ：
 那些运行在节点的主机网络里的 pods 可以不通过 NAT 和所有节点上的 pods 通信  这个模型不仅不复杂，而且还和 Kubernetes 的实现廉价的从虚拟机向容器迁移的初衷相兼容，如果你的工作开始是在虚拟机中运行的，你的虚拟机有一个 IP ，这样就可以和其他的虚拟机进行通信，这是基本相同的模型。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Kubernetes 网络" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cctrip.github.io/notes/docs/technology/cloud/Container/Kubernetes/network/" />

<title>Kubernetes 网络 | 学而不思则罔</title>
<link rel="manifest" href="/notes/manifest.json">
<link rel="icon" href="/notes/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/notes/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/notes/en.search.min.27c814e55044cec2ffeac8f549f302a581d49eb85ab65f63caf53e8f486af6d5.js" integrity="sha256-J8gU5VBEzsL/6sj1SfMCpYHUnrhatl9jyvU&#43;j0hq9tU="></script>

<script defer src="/notes/sw.min.2ab779ae2b5d50aeddfdd9ec3d03b41a76a3dc7461eedf8a74bbc49ef33e61e8.js" integrity="sha256-Krd5ritdUK7d/dnsPQO0Gnaj3HRh7t&#43;KdLvEnvM&#43;Yeg="></script>
<link rel="alternate" type="application/rss+xml" href="https://cctrip.github.io/notes/docs/technology/cloud/Container/Kubernetes/network/index.xml" title="学而不思则罔" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/notes"><img src="/notes/cc.jpg" alt="Logo" /><span>学而不思则罔</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  
  
  

  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
    <a href="/notes/docs/technology/" class="">技术相关</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/docs/technology/system/" class="collapsed ">系统</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/network/" class="collapsed ">网络</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/program/" class="collapsed ">编程</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/database/" class="collapsed ">数据库</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/architecture/" class="collapsed ">架构</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/" class="collapsed ">云原生</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/infrastructure/" class="">不可变基础设施</a>
  

          
  
  
  

  
  <ul>
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/" class="collapsed ">容器技术</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/map/" class="">技能图谱</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Docker/" class="collapsed ">Docker</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/" class="collapsed ">Kubernetes</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/map/" class="">技能图谱</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/arch/" class="">Kubernetes 架构</a>
  

          
  
  
  

  
  <ul>
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/api/" class="collapsed ">Kubernetes API</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/object/" class="collapsed ">Kubernetes 对象</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/network/" class="collapsed active">Kubernetes 网络</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/network/flannel/" class="">Flannel</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/network/service/" class="">Service通信</a>
  

          
  
  
  

  
  <ul>
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/network/calico/" class="">Calico</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/network/cilium/" class="">Cilium</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/network/aws/" class="">AWS VPC CNI</a>
  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/storage/" class="collapsed ">Kubernetes 存储</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/security/" class="collapsed ">Kubernetes 安全</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Container/Kubernetes/operation/" class="collapsed ">Kubernetes 操作</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/ServiceMesh/" class="collapsed ">服务网格</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/Microservice/" class="collapsed ">微服务</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/API/" class="collapsed ">声明式API</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/cloud/DevOps/" class="collapsed ">DevOps</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/bigdata/" class="collapsed ">大数据</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/security/" class="collapsed ">安全</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/tool/" class="collapsed ">工具</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/other/" class="collapsed ">其他</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/technology/howto/" class="collapsed ">How To</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
    <a href="/notes/docs/other/" class="">非技术相关</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/docs/other/life/" class="collapsed ">人生</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/docs/other/learn/" class="collapsed ">方法论</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
  </ul>
  











  
<ul>
  
  <li>
    <a href="https://cctrip.github.io/" target="_blank" rel="noopener">
        关于我
      </a>
  </li>
  
  <li>
    <a href="https://cctrip.github.io/posts" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/cctrip/notes" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/notes/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Kubernetes 网络</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h1 id="kubernetes-网络">
  Kubernetes 网络
  <a class="anchor" href="#kubernetes-%e7%bd%91%e7%bb%9c">#</a>
</h1>
<p>集群网络系统是 Kubernetes 的核心部分，但是想要准确了解它的工作原理可是个不小的挑战。下面列出的是网络系统的的四个主要问题：</p>
<ol>
<li>高度耦合的容器间通信：这个已经被 
  <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod">pods</a> 和 <code>localhost</code> 通信解决了。</li>
<li>Pod 间通信：这个是本文档的重点要讲述的。</li>
<li>Pod 和 Service 间通信：这个已经在 
  <a href="https://kubernetes.io/docs/concepts/services-networking/service/">services</a> 里讲述过了。</li>
<li>外部和 Service 间通信：这个也已经在 
  <a href="https://kubernetes.io/docs/concepts/services-networking/service/">services</a> 讲述过了。</li>
</ol>
<p>Kubernetes 的宗旨就是在应用之间共享机器。通常来说，共享机器需要两个应用之间不能使用相同的端口，但是在多个应用开发者之间去大规模地协调端口是件很困难的事情，尤其是还要让用户暴露在他们控制范围之外的集群级别的问题上。</p>
<p>动态分配端口也会给系统带来很多复杂度 - 每个应用都需要设置一个端口的参数，而 API 服务器还需要知道如何将动态端口数值插入到配置模块中，服务也需要知道如何找到对方等等。与其去解决这些问题，Kubernetes 选择了其他不同的方法。</p>
<h2 id="kubernetes-网络模型">
  Kubernetes 网络模型
  <a class="anchor" href="#kubernetes-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b">#</a>
</h2>
<p>每一个 <code>Pod</code> 都有它自己的IP地址，这就意味着你不需要显式地在每个 <code>Pod</code> 之间创建链接，你几乎不需要处理容器端口到主机端口之间的映射。这将创建一个干净的、向后兼容的模型，在这个模型里，从端口分配、命名、服务发现、负载均衡、应用配置和迁移的角度来看，<code>Pod</code> 可以被视作虚拟机或者物理主机。</p>
<p>Kubernetes 对所有网络设施的实施，都需要满足以下的基本要求（除非有设置一些特定的网络分段策略）：</p>
<ul>
<li>节点上的 pods 可以不通过 NAT 和其他任何节点上的 pods 通信</li>
<li>节点上的代理（比如：系统守护进程、kubelet） 可以和节点上的所有pods通信</li>
</ul>
<p>备注：仅针对那些支持 <code>Pods</code> 在主机网络中运行的平台(比如：Linux) ：</p>
<ul>
<li>那些运行在节点的主机网络里的 pods 可以不通过 NAT 和所有节点上的 pods 通信</li>
</ul>
<p>这个模型不仅不复杂，而且还和 Kubernetes 的实现廉价的从虚拟机向容器迁移的初衷相兼容，如果你的工作开始是在虚拟机中运行的，你的虚拟机有一个 IP ，这样就可以和其他的虚拟机进行通信，这是基本相同的模型。</p>
<p>Kubernetes 的 IP 地址存在于 <code>Pod</code> 范围内 - 容器分享他们的网络命名空间 - 包括他们的 IP 地址。这就意味着 <code>Pod</code> 内的容器都可以通过 <code>localhost</code> 到达各个端口。这也意味着 <code>Pod</code> 内的容器都需要相互协调端口的使用，但是这和虚拟机中的进程似乎没有什么不同，这也被称为“一个 pod 一个 IP” 模型。</p>
<p>如何实现这一点是正在使用的容器运行时的特定信息。</p>
<p>也可以在 <code>node</code> 本身通过端口去请求你的 <code>Pod</code> （称之为主机端口），但这是一个很特殊的操作。转发方式如何实现也是容器运行时的细节。<code>Pod</code> 自己并不知道这些主机端口是否存在。</p>
<h2 id="如何实现-kubernetes-的网络模型">
  如何实现 Kubernetes 的网络模型
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-kubernetes-%e7%9a%84%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b">#</a>
</h2>
<p>有很多种方式可以实现这种网络模型，本文档并不是对各种实现技术的详细研究，但是希望可以作为对各种技术的详细介绍，并且成为你研究的起点。</p>
<p>接下来的网络技术是按照首字母排序，并无其他任何含义。</p>
<h3 id="aci">
  ACI
  <a class="anchor" href="#aci">#</a>
</h3>
<p>
  <a href="https://www.cisco.com/c/en/us/solutions/data-center-virtualization/application-centric-infrastructure/index.html">Cisco Application Centric Infrastructure</a> 提供了一个集成覆盖和底层 SDN 解决方案来支持容器、虚拟机和其他裸机服务器。
  <a href="https://www.github.com/noironetworks/aci-containers">ACI</a> 为ACI提供了容器网络集成。点击
  <a href="https://www.cisco.com/c/dam/en/us/solutions/collateral/data-center-virtualization/application-centric-infrastructure/solution-overview-c22-739493.pdf">这里</a>查看概述</p>
<h3 id="antrea">
  Antrea
  <a class="anchor" href="#antrea">#</a>
</h3>
<p>
  <a href="https://github.com/vmware-tanzu/antrea">Antrea</a> 项目是一个开源的，旨在成为 Kubernetes 原生的网络解决方案。它利用 Open vSwitch 作为网络数据平面。Open vSwitch 是一个高性能可编程的虚拟交换机，支持 Linux 和 Windows 平台。Open vSwitch 使 Antrea 能够以高性能和高效的方式实现 Kubernetes 的网络策略。借助 Open vSwitch 可编程的特性， Antrea 能够在 Open vSwitch 之上实现广泛的网络，安全功能和服务。</p>
<h3 id="apstra-中的-aos">
  Apstra 中的 AOS
  <a class="anchor" href="#apstra-%e4%b8%ad%e7%9a%84-aos">#</a>
</h3>
<p>
  <a href="http://www.apstra.com/products/aos/">AOS</a> 是一个基于意图的网络系统，可以通过一个简单的集成平台创建和管理复杂的数据中心环境。AOS 利用高度可扩展的分布式设计来消除网络中断，同时将成本降至最低。</p>
<p>AOS 参考设计当前支持三层连接的主机，这些主机消除了旧的两层连接的交换问题。这些三层连接的主机可以是 Linux（Debian、Ubuntu、CentOS）系统，它们直接在机架式交换机（TOR）的顶部创建 BGP 邻居关系。AOS 自动执行路由邻接，然后提供对 Kubernetes 部署中常见的路由运行状况注入（RHI）的精细控制。</p>
<p>AOS 具有一组丰富的 REST API 端点，这些端点使 Kubernetes 能够根据应用程序需求快速更改网络策略。进一步的增强功能将用于网络设计的 AOS Graph 模型与工作负载供应集成在一起，从而为私有云和公共云提供端到端管理系统。</p>
<p>AOS 支持使用包括 Cisco、Arista、Dell、Mellanox、HPE 在内的制造商提供的通用供应商设备，以及大量白盒系统和开放网络操作系统，例如 Microsoft SONiC、Dell OPX 和 Cumulus Linux 。</p>
<p>想要更详细地了解 AOS 系统是如何工作的可以点击这里： <a href="http://www.apstra.com/products/how-it-works/">http://www.apstra.com/products/how-it-works/</a></p>
<h3 id="kubernetes-的-aws-vpc-cni">
  Kubernetes 的 AWS VPC CNI
  <a class="anchor" href="#kubernetes-%e7%9a%84-aws-vpc-cni">#</a>
</h3>
<p>
  <a href="https://github.com/aws/amazon-vpc-cni-k8s">AWS VPC CNI</a> 为 Kubernetes 集群提供了集成的 AWS 虚拟私有云（VPC）网络。该 CNI 插件提供了高吞吐量和可用性，低延迟以及最小的网络抖动。此外，用户可以使用现有的 AWS VPC 网络和安全最佳实践来构建 Kubernetes 集群。这包括使用 VPC 流日志，VPC 路由策略和安全组进行网络流量隔离的功能。</p>
<p>使用该 CNI 插件，可使 Kubernetes Pods 在 Pod 中拥有与在 VPC 网络上相同的 IP 地址。CNI 将 AWS 弹性网络接口（ENI）分配给每个 Kubernetes 节点，并将每个 ENI 的辅助 IP 范围用于该节点上的 Pod 。CNI 包含用于 ENI 和 IP 地址的预分配的控件，以便加快 Pod 的启动时间，并且能够支持多达2000个节点的大型集群。</p>
<p>此外，CNI可以与
  <a href="https://docs.aws.amazon.com/eks/latest/userguide/calico.html">用于执行网络策略的 Calico</a>一起运行。 AWS VPC CNI项目是开源的，查看 
  <a href="https://github.com/aws/amazon-vpc-cni-k8s">GitHub 上的文档</a>。</p>
<h3 id="kubernetes-的-azure-cni">
  Kubernetes 的 Azure CNI
  <a class="anchor" href="#kubernetes-%e7%9a%84-azure-cni">#</a>
</h3>
<p>
  <a href="https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview">Azure CNI</a> 是一个
  <a href="https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md">开源插件</a>，将 Kubernetes Pods 和 Azure 虚拟网络（也称为 VNet）集成在一起，可提供与 VN 相当的网络性能。Pod 可以通过 Express Route 或者 站点到站点的 VPN 来连接到对等的 VNet ，也可以从这些网络来直接访问 Pod。Pod 可以访问受服务端点或者受保护链接的 Azure 服务，比如存储和 SQL。你可以使用 VNet 安全策略和路由来筛选 Pod 流量。该插件通过利用在 Kubernetes 节点的网络接口上预分配的辅助 IP 池将 VNet 分配给 Pod 。</p>
<p>Azure CNI 可以在 
  <a href="https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni">Azure Kubernetes Service (AKS)</a> 中获得。</p>
<h3 id="big-switch-networks-的-big-cloud-fabric">
  Big Switch Networks 的 Big Cloud Fabric
  <a class="anchor" href="#big-switch-networks-%e7%9a%84-big-cloud-fabric">#</a>
</h3>
<p>
  <a href="https://www.bigswitch.com/container-network-automation">Big Cloud Fabric</a> 是一个基于云原生的网络架构，旨在在私有云或者本地环境中运行 Kubernetes。它使用统一的物理和虚拟 SDN，Big Cloud Fabric 解决了固有的容器网络问题，比如负载均衡、可见性、故障排除、安全策略和容器流量监控。</p>
<p>在 Big Cloud Fabric 的虚拟 Pod 多租户架构的帮助下，容器编排系统（比如 Kubernetes、RedHat OpenShift、Mesosphere DC/OS 和 Docker Swarm）将于VM本地编排系统（比如 VMware、OpenStack 和 Nutanix）进行本地集成。客户将能够安全地互联任意数量的这些集群，并且在需要时启用他们之间的租户间通信。</p>
<p>在最新的 
  <a href="http://go.bigswitch.com/17GatedDocuments-MagicQuadrantforDataCenterNetworking_Reg.html">Magic Quadrant</a> 上，BCF 被 Gartner 认为是非常有远见的。而 BCF 的一条关于 Kubernetes 的本地部署（其中包括 Kubernetes、DC/OS 和在不同地理区域的多个 DC 上运行的 VMware）也在
  <a href="https://portworx.com/architects-corner-kubernetes-satya-komala-nio/">这里</a>被引用。</p>
<h3 id="cilium">
  Cilium
  <a class="anchor" href="#cilium">#</a>
</h3>
<p>
  <a href="https://github.com/cilium/cilium">Cilium</a> 是一个开源软件，用于提供并透明保护应用容器间的网络连接。Cilium 支持 L7/HTTP ，可以在 L3-L7 上通过使用与网络分离的基于身份的安全模型寻址来实施网络策略，并且可以与其他 CNI 插件结合使用。</p>
<h3 id="华为的-cni-genie">
  华为的 CNI-Genie
  <a class="anchor" href="#%e5%8d%8e%e4%b8%ba%e7%9a%84-cni-genie">#</a>
</h3>
<p>
  <a href="https://github.com/Huawei-PaaS/CNI-Genie">CNI-Genie</a> 是一个 CNI 插件，可以让 Kubernetes 在运行时允许不同的 
  <a href="https://github.com/kubernetes/website/blob/master/content/en/docs/concepts/cluster-administration/networking.md#the-kubernetes-network-model">Kubernetes 的网络模型</a>的
  <a href="https://github.com/Huawei-PaaS/CNI-Genie/blob/master/docs/multiple-cni-plugins/README.md#what-cni-genie-feature-1-multiple-cni-plugins-enables">实现同时被访问</a>。这包括以 
  <a href="https://github.com/containernetworking/cni#3rd-party-plugins">CNI 插件</a>运行的任何实现，比如 
  <a href="https://github.com/coreos/flannel#flannel">Flannel</a>、
  <a href="http://docs.projectcalico.org/">Calico</a>、
  <a href="http://romana.io/">Romana</a>、
  <a href="https://www.weave.works/products/weave-net/">Weave-net</a>。</p>
<p>CNI-Genie 还支持
  <a href="https://github.com/Huawei-PaaS/CNI-Genie/blob/master/docs/multiple-ips/README.md#feature-2-extension-cni-genie-multi-ip-addresses-per-pod">将多个 IP 地址分配给 Pod</a>，每个都来自不同的 CNI 插件。</p>
<h3 id="cni-ipvlan-vpc-k8s">
  cni-ipvlan-vpc-k8s
  <a class="anchor" href="#cni-ipvlan-vpc-k8s">#</a>
</h3>
<p>
  <a href="https://github.com/lyft/cni-ipvlan-vpc-k8s">cni-ipvlan-vpc-k8s</a> 包含了一组 CNI 和 IPAM 插件来提供一个简单的、本地主机、低延迟、高吞吐量以及通过使用 Amazon 弹性网络接口（ENI）并使用 Linux 内核的 IPv2 驱动程序以 L2 模式将 AWS 管理的 IP 绑定到 Pod 中，在 Amazon Virtual Private Cloud（VPC）环境中为 Kubernetes 兼容的网络堆栈。</p>
<p>这些插件旨在直接在 VPC 中进行配置和部署，Kubelets 先启动，然后根据需要进行自我配置和扩展它们的 IP 使用率，而无需经常建议复杂的管理覆盖网络， BGP ，禁用源/目标检查，或调整 VPC 路由表以向每个主机提供每个实例子网的复杂性（每个 VPC 限制为50-100个条目）。简而言之， cni-ipvlan-vpc-k8s 大大降低了在 AWS 中大规模部署 Kubernetes 所需的网络复杂性。</p>
<h3 id="contiv">
  Contiv
  <a class="anchor" href="#contiv">#</a>
</h3>
<p>
  <a href="https://github.com/contiv/netplugin">Contiv</a> 为各种使用情况提供了一个可配置网络（使用了 BGP 的本地 l3 ，使用 vxlan 的覆盖，经典 l2 或 Cisco-SDN/ACI）。
  <a href="http://contiv.io/">Contiv</a> 是完全开源的。</p>
<h3 id="contrail--tungsten-fabric">
  Contrail / Tungsten Fabric
  <a class="anchor" href="#contrail--tungsten-fabric">#</a>
</h3>
<p>
  <a href="http://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/">Contrail</a> 是基于 
  <a href="https://tungsten.io/">Tungsten Fabric</a> 的，真正开放的，多云网络虚拟化和策略管理平台。Contrail 和 Tungsten Fabric 与各种编排系统集成在一起，例如 Kubernetes，OpenShift，OpenStack 和 Mesos，并为虚拟机、容器或 Pods 以及裸机工作负载提供了不同的隔离模式。</p>
<h3 id="danm">
  DANM
  <a class="anchor" href="#danm">#</a>
</h3>
<p>
  <a href="https://github.com/nokia/danm">DANM</a> 是一个针对在 Kubernetes 集群中运行的电信工作负载的网络解决方案。它由以下几个组件构成：</p>
<pre><code>* 能够配置具有高级功能的 IPVLAN 接口的 CNI 插件
* 一个内置的 IPAM 模块，能够管理多个、群集内的、不连续的 L3 网络，并按请求提供动态、静态或无 IP 分配方案
* CNI 元插件能够通过自己的 CNI 或通过将任务授权给其他任何流行的 CNI 解决方案（例如 SRI-OV 或 Flannel）来实现将多个网络接口连接到容器
* Kubernetes 控制器能够集中管理所有 Kubernetes 主机的 VxLAN 和 VLAN 接口
* 另一个 Kubernetes 控制器扩展了 Kubernetes 的基于服务的服务发现概念，以在 Pod 的所有网络接口上工作
</code></pre><p>通过这个工具集，DANM 可以提供多个分离的网络接口，可以为 pods 使用不同的网络后端和高级 IPAM 功能。</p>
<h3 id="flannel">
  Flannel
  <a class="anchor" href="#flannel">#</a>
</h3>
<p>
  <a href="https://github.com/coreos/flannel#flannel">Flannel</a> 是一个非常简单的能够满足 Kubernetes 所需要的重叠网络。已经有许多人报告了使用 Flannel 和 Kubernetes 的成功案例。</p>
<h3 id="google-compute-engine-gce">
  Google Compute Engine (GCE)
  <a class="anchor" href="#google-compute-engine-gce">#</a>
</h3>
<p>对于 Google Compute Engine 的集群配置脚本，
  <a href="https://cloud.google.com/vpc/docs/routes">advanced routing</a> 用于为每个虚机分配一个子网（默认是 <code>/24</code> - 254个 IP），绑定到该子网的任何流量都将通过 GCE 网络结构直接路由到虚机。这是除了分配给虚机的“主要” IP 地址之外的一个补充，该 IP 地址经过 NAT 转换以用于访问外网。linux网桥（称为“cbr0”）被配置为存在于该子网中，并被传递到 docker 的 &ndash;bridge 参数上。</p>
<p>Docker 会以这样的参数启动：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">DOCKER_OPTS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--bridge=cbr0 --iptables=false --ip-masq=false&#34;</span>
</code></pre></div><p>这个网桥是由 Kubelet（由 &ndash;network-plugin=kubenet 参数控制）根据节点的 .spec.podCIDR 参数创建的。</p>
<p>Docker 将会从 <code>cbr-cidr</code> 块分配 IP 。容器之间可以通过 cbr0 网桥相互访问，也可以访问节点。这些 IP 都可以在 GCE 的网络中被路由。</p>
<p>而 GCE 本身并不知道这些 IP，所以不会对访问外网的流量进行 NAT，为了实现此目的，使用了 iptables 规则来伪装（又称为 SNAT，使数据包看起来好像是来自“节点”本身），将通信绑定到 GCE 项目网络（10.0.0.0/8）之外的 IP。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">iptables -t nat -A POSTROUTING ! -d 10.0.0.0/8 -o eth0 -j MASQUERADE
</code></pre></div><p>最后，在内核中启用了 IP 转发（因此内核将处理桥接容器的数据包）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sysctl net.ipv4.ip_forward<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p>所有这些的结果是所有 <code>Pods</code> 都可以互相访问，并且可以将流量发送到互联网。</p>
<h3 id="jaguar">
  Jaguar
  <a class="anchor" href="#jaguar">#</a>
</h3>
<p>
  <a href="https://gitlab.com/sdnlab/jaguar">Jaguar</a> 是一个基于 OpenDaylight 的 Kubernetes 网络开源解决方案。Jaguar 使用 vxlan 提供覆盖网络，而 Jaguar CNIPlugin 为每个 Pod 提供一个 IP 地址。</p>
<h3 id="k-vswitch">
  k-vswitch
  <a class="anchor" href="#k-vswitch">#</a>
</h3>
<p>
  <a href="https://github.com/k-vswitch/k-vswitch">k-vswitch</a> 是一个基于 
  <a href="https://www.openvswitch.org/">Open vSwitch</a> 的简易 Kubernetes 网络插件。它利用 Open vSwitch 中现有的功能来提供强大的网络插件，该插件易于操作，高效且安全。</p>
<h3 id="knitter">
  Knitter
  <a class="anchor" href="#knitter">#</a>
</h3>
<p>
  <a href="https://github.com/ZTE/Knitter/">Knitter</a> 是一个支持 Kubernetes 中实现多个网络系统的解决方案。它提供了租户管理和网络管理的功能。除了多个网络平面外，Knitter 还包括一组端到端的 NFV 容器网络解决方案，例如为应用程序保留 IP 地址，IP 地址迁移等。</p>
<h3 id="kube-ovn">
  Kube-OVN
  <a class="anchor" href="#kube-ovn">#</a>
</h3>
<p>
  <a href="https://github.com/alauda/kube-ovn">Kube-OVN</a> 是一个基于 OVN 的用于企业的 Kubernetes 网络架构。借助于 OVN/OVS ，它提供了一些高级覆盖网络功能，例如子网、QoS、静态 IP 分配、流量镜像、网关、基于开放流的网络策略和服务代理。</p>
<h3 id="kube-router">
  Kube-router
  <a class="anchor" href="#kube-router">#</a>
</h3>
<p>
  <a href="https://github.com/cloudnativelabs/kube-router">Kube-router</a> 是 Kubernetes 的专用网络解决方案，旨在提供高性能和易操作性。 Kube-router 提供了一个基于 Linux 
  <a href="http://www.linuxvirtualserver.org/software/ipvs.html">LVS/IPVS</a> 的服务代理，一个基于 Linux 内核转发的无覆盖 Pod-to-Pod 网络解决方案，和基于 iptables/ipset 的网络策略执行器。</p>
<h3 id="l2-networks-and-linux-bridging">
  L2 networks and linux bridging
  <a class="anchor" href="#l2-networks-and-linux-bridging">#</a>
</h3>
<p>如果你具有一个“哑”的L2网络，例如“裸机”环境中的简单交换机，则应该能够执行与上述 GCE 设置类似的操作。请注意，这些说明仅是非常简单的尝试过-似乎可行，但尚未经过全面测试。如果您使用此技术并完善了流程，请告诉我们。</p>
<p>根据 Lars Kellogg-Stedman 的这份非常不错的“Linux 网桥设备”
  <a href="http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/">使用说明</a>来进行操作。</p>
<h3 id="multus-a-multi-network-plugin">
  Multus (a Multi Network plugin)
  <a class="anchor" href="#multus-a-multi-network-plugin">#</a>
</h3>
<p>
  <a href="https://github.com/Intel-Corp/multus-cni">Multus</a> 是一个多 CNI 插件，使用 Kubernetes 中基于 CRD 的网络对象来支持实现 Kubernetes 多网络系统。</p>
<p>Multus 支持所有[参考插件]（https://github.com/containernetworking/plugins）（比如： 
  <a href="https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel">Flannel</a>、
  <a href="https://github.com/containernetworking/plugins/tree/master/plugins/ipam/dhcp">DHCP</a>、
  <a href="https://github.com/containernetworking/plugins/tree/master/plugins/main/macvlan">Macvlan</a> ），来实现 CNI 规范和第三方插件（比如： 
  <a href="https://github.com/projectcalico/cni-plugin">Calico</a>、
  <a href="https://github.com/weaveworks/weave">Weave</a>、
  <a href="https://github.com/cilium/cilium">Cilium</a>、
  <a href="https://github.com/contiv/netplugin">Contiv</a>）。除此之外， Multus 还支持 
  <a href="https://github.com/hustcat/sriov-cni">SRIOV</a>、
  <a href="https://github.com/Intel-Corp/sriov-cni">DPDK</a>、
  <a href="https://github.com/intel/vhost-user-net-plugin">OVS-DPDK &amp; VPP</a> 的工作负载，以及 Kubernetes 中基于云的本机应用程序和基于 NFV 的应用程序。</p>
<h3 id="nsx-t">
  NSX-T
  <a class="anchor" href="#nsx-t">#</a>
</h3>
<p>
  <a href="https://docs.vmware.com/en/VMware-NSX-T/index.html">VMware NSX-T</a> 是一个网络虚拟化的安全平台。 NSX-T 可以为多云及多系统管理程序环境提供网络虚拟化，并专注于具有异构端点和技术堆栈的新兴应用程序框架和体系结构。除了 vSphere 管理程序之外，这些环境还包括其他虚拟机管理程序，例如 KVM，容器和裸机。</p>
<p>
  <a href="https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf">NSX-T Container Plug-in (NCP)</a> 提供了 NSX-T 与容器协调器（例如 Kubernetes）之间的结合， 以及 NSX-T 与基于容器的 CaaS/PaaS 平台（例如 Pivotal Container Service（PKS） 和 OpenShift ）之间的集成。</p>
<h3 id="nuage-networks-vcs-virtualized-cloud-services">
  Nuage Networks VCS (Virtualized Cloud Services)
  <a class="anchor" href="#nuage-networks-vcs-virtualized-cloud-services">#</a>
</h3>
<p>
  <a href="http://www.nuagenetworks.net/">Nuage</a> 提供了一个高度可扩展的基于策略的软件定义网络（SDN）平台，Nuage 使用开源的 Open vSwitch 作为数据平面，以及基于开放标准构建具有丰富功能的 SDN 控制器。</p>
<p>Nuage 平台使用覆盖层在 Kubernetes Pod 和非 Kubernetes 环境（VM 和裸机服务器）之间提供基于策略的无缝联网。Nuage 的策略抽象模型在设计时就考虑到了应用程序，并且可以轻松声明应用程序的细粒度策略。该平台的实时分析引擎可为 Kubernetes 应用程序提供可见性和安全性监控。</p>
<h3 id="openvswitch">
  OpenVSwitch
  <a class="anchor" href="#openvswitch">#</a>
</h3>
<p>
  <a href="https://www.openvswitch.org/">OpenVSwitch</a> 是一个较为成熟的解决方案，但同时也增加了构建覆盖网络的复杂性，这也得到了几个网络系统的“大商店”的拥护。</p>
<h3 id="ovn-开放式虚拟网络">
  OVN (开放式虚拟网络)
  <a class="anchor" href="#ovn-%e5%bc%80%e6%94%be%e5%bc%8f%e8%99%9a%e6%8b%9f%e7%bd%91%e7%bb%9c">#</a>
</h3>
<p>OVN 是一个由 Open vSwitch 社区开发的开源的网络虚拟化解决方案。它允许创建逻辑交换器，逻辑路由，状态 ACL，负载均衡等等来建立不同的虚拟网络拓扑。该项目有一个特定的Kubernetes插件和文档 
  <a href="https://github.com/openvswitch/ovn-kubernetes">ovn-kubernetes</a>。</p>
<h3 id="project-calico">
  Project Calico
  <a class="anchor" href="#project-calico">#</a>
</h3>
<p>
  <a href="http://docs.projectcalico.org/">Project Calico</a> 是一个开源的容器网络提供者和网络策略引擎。</p>
<p>Calico 提供了高度可扩展的网络和网络解决方案，使用基于与 Internet 相同的 IP 网络原理来连接 Kubernetes Pod，适用于 Linux （开放源代码）和 Windows（专有-可从 
  <a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/https//www.tigera.io/essentials/">Tigera</a> 获得。可以无需封装或覆盖即可部署 Calico，以提供高性能，高可扩的数据中心网络。Calico 还通过其分布式防火墙为 Kubernetes Pod 提供了基于意图的细粒度网络安全策略。</p>
<p>Calico 还可以和其他的网络解决方案（比如 Flannel、
  <a href="https://github.com/tigera/canal">canal</a> 或本机 GCE、AWS、Azure 等）一起以策略实施模式运行。</p>
<h3 id="romana">
  Romana
  <a class="anchor" href="#romana">#</a>
</h3>
<p>
  <a href="http://romana.io/">Romana</a> 是一个开源网络和安全自动化解决方案。它可以让你在没有覆盖网络的情况下部署 Kubernetes。Romana 支持 Kubernetes 
  <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">网络策略</a>，来提供跨网络命名空间的隔离。</p>
<h3 id="weaveworks-的-weave-net">
  Weaveworks 的 Weave Net
  <a class="anchor" href="#weaveworks-%e7%9a%84-weave-net">#</a>
</h3>
<p>
  <a href="https://www.weave.works/products/weave-net/">Weave Net</a> 是 Kubernetes 及其托管应用程序的弹性和易于使用的网络系统。Weave Net 可以作为 
  <a href="https://www.weave.works/docs/net/latest/cni-plugin/">CNI plug-in</a> 运行或者独立运行。在这两种运行方式里，都不需要任何配置或额外的代码即可运行，并且在两种情况下，网络都为每个 Pod 提供一个 IP 地址-这是 Kubernetes 的标准配置。</p>
接下来<h2 id="接下来-httpskubernetesiozhdocsconceptscluster-administrationnetworking接下来">
  
  <a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/#%e6%8e%a5%e4%b8%8b%e6%9d%a5"> </a>
  <a class="anchor" href="#%e6%8e%a5%e4%b8%8b%e6%9d%a5-httpskubernetesiozhdocsconceptscluster-administrationnetworking%e6%8e%a5%e4%b8%8b%e6%9d%a5">#</a>
</h2>
<p>网络模型的早期设计、运行原理以及未来的一些计划，都在 
  <a href="https://git.k8s.io/community/contributors/design-proposals/network/networking.md">networking design document</a> 文档里进行了更详细的描述。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/cctrip/notes/commit/134c57607de5eb79d7413ba2e5a8b9b4f80e4908" title='Last modified by codecc | August 17, 2020' target="_blank" rel="noopener">
      <img src="/notes/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>August 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/cctrip/notes/edit/master/content/docs/technology/cloud/Container/Kubernetes/network/_index.md" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  
</body>

</html>












