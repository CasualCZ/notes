'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/notes/docs/technology/','title':"DevOps笔记",'content':"DevOps笔记 #  系统 #    计算机基础\n   计算机组成\n   操作系统\n   文件系统\n    Linux系统\n   内核编译\n   启动\n   Linux目录结构\n   Linux操作指南\n    应用服务\n   Ssh\n   Nginx\n   Tomcat\n     网络 #    网络基础\n   网络协议\n  TCP\n  HTTP\n  DNS\n  TLS\n    路由交换\n   数据库 #    数据库基础\n   PostgreSQL\n   MySQL\n   Redis\n   编程 #     编程基础\n   版本控制\n  Git     Shell\n   Python\n  GoLang\n   编程进阶\n   算法\n   数据结构\n   设计模式\n     安全 #     安全基础\n   TLS\n   Firewall\n   IDS\n   Snort\n  Ossec\n  tripware\n     大数据 #     基础概念\n   Zookeeper\n   Kafka\n   智能化 #     Ansible\n   Docker\n   Kubernetes\n   Elk\n   工具 #     TCPCopy\n   Script\n   其他 #     LeetCode解题\n   我的环境配置\n   问题集锦\n   学习方法\n   我的博客\n   读书笔记\n   翻译\n   "});index.add({'id':1,'href':'/notes/docs/technology/cloud/Docker/','title':"Docker",'content':"Docker #  容器，操作系统层面的虚拟化技术。\n 基本概念 #     镜像\n   容器\n   仓库\n   安装 #  Docker安装\n#删除旧版本 yum remove docker docker-common docker-selinux docker-engine #获取repository文件 yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo #安装新版本 yum install docker-ce #启动 systemctl start docker.service   基本使用 #    docker pull :\n获取镜像\n  docker run [options] : options\n -v \u0026lt;local_dir\u0026gt;:\u0026lt;container_dir\u0026gt; -p \u0026lt;local_port\u0026gt;:\u0026lt;container_port\u0026gt; -i 交互模式 -d 后台运行 -t 使用tty    docker ps 查看容器\n  docker images 查看镜像\n  docker inspect container_name 查看容器配置\n  docker build -t tag -f /PATH/Dockerfile 通过Dockerfile文件构建镜像\n   Dockerfile #  Dockerfile编写\nFROM \u0026lt;imagename\u0026gt;:\u0026lt;version\u0026gt; #基于某个镜像 ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; #设置环境变量 RUN command #执行命令 COPY \u0026lt;local_file\u0026gt; \u0026lt;container_path\u0026gt; #拷贝本地文件到容器 ENTRYPOINT #执行启动命令 CMD   "});index.add({'id':2,'href':'/notes/docs/technology/system/Linux/Kernel/kernel/','title':"内核编译",'content':"内核编译 #  概念 #  内核指的是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。\n一般保存在/boot目录中，格式为/boot/vmlinuz-XXX\n 为什么要编译内核 #    需要新功能支持\n  原核心过于臃肿\n  与硬件搭配的稳定性\n  其他特殊需求\n   编译内核 #    下载源码包， https://www.kernel.org/\n  解压内核包，一般放在/usr/src/kernels目录下\n tar -Jxf /root/linux-3.16.39.tar.xz -C /usr/src/kernels/    进入内核目录\n cd /usr/src/kernels/linux-3.16.39    查看内核目录( 目录说明)\n ls -d ./*/ ./arch/ ./crypto/ ./drivers/ ./fs/ ./init/ ./kernel/ ./mm/ ./samples/ ./security/ ./tools/ ./virt/ ./block/ ./Documentation/ ./firmware/ ./include/ ./ipc/ ./lib/ ./net/ ./scripts/ ./sound/ ./usr/    清空源代码的其他信息\n下载下来的源码包一般情况下不确定是否已经编译过，或者还残留有生成的一起文件，为了编译时不会出现未知的错误，进行清理。\n make mrproper    核心功能挑选(生成.config文件)( 选择界面说明)\n yum install ncurses-devel -y make menuconfig    生成bzImage内核 arch/x86/boot/bzImage\n make -j 4 clean make -j 4 bzImage ll arch/x86/boot/bzImage    编译安装模块\n make -j 4 modules make modules_install    手动添加内核\n #拷贝内核文件到/boot目录底下 cp arch/x86/boot/bzImage /boot/vmlinuz-`basename /lib/modules/3.16.39/` #备份.config文件 cp .config /boot/config-`basename /lib/modules/3.16.39/` #添加可执行权限 chmod a+x /boot/vmlinuz-3.16.39 #拷贝系统内核映射文件 cp System.map /boot/System.map-`basename /lib/modules/3.16.39/` #拷贝内核模块列表 gzip -c Module.symvers \u0026gt; /boot/symvers-`basename /lib/modules/3.16.39/`.gz    配置grub\n#生成对应版本的initramfs文件 dracut -v /boot/initramfs-`basename /lib/modules/3.16.39/` 3.16.39 #更新grub.cfg配置，加入新内核记录 grub2-mkconfig -o /boot/grub2/grub.cfg    查看grub配置/boot/grub2/grub.conf\n   重启机器，选择新内核启动\n   目录说明   arch：与硬件平台有关的项目，大部分指的是CPU的类型，例如x86,x86_64,Xen虚拟支持等。\n  block：与成组设备较相关的设定数据，区块数据通常指一些大量存储媒体，还包括类似ext3等文件系统的支持是否允许等。\n  crypto：核心所支持的加密技术，如md5、des、sha512等。\n  Documentation：与核心有关的一堆说明文件，其中包括了对上面所有目录里的说明。\n  firmware：一些旧式硬件的微脚步数据。\n  fs：内核所支持的filesystems（文件系统），例如ext系列、ntfs、reisefs等。\n  include：一些可让其它过程调用的标头(header)定义数据。\n  init：一些初始化的定义功能，包括挂载和init 程序的呼叫等。\n  ipc：定义Linux操作系统内各程序进程间的通信。\n  kernel：定义核心的程序、核心状态、线程、程序的排程(schedule)、程序的讯号(signle)等。\n  lib：一些函数库。\n  mm：与内存单元有关的各项数据，包括swap与虚拟内存等。\n  net：与网络有关的各项协议数据，还有防火墙模块(net/ipv4/netfilter/*) 等。\n  security：包括selinux等在内的安全性设定。\n  sound：与音效有关的各项模块。\n  virt：与虚拟化机器有关的信息，目前核心支持的是KVM( Kernel base Vitual Machine )。\n   选择界面说明   make help： 支持“更新模式进行配置”。\n  make menuconfig： 基于curses的文本窗口界面\n  make gconfig： 基于GTK(GOME)环境窗口界面\n  make xconfig： 基于QT(KDE) 环境的窗口界面\n  make config： 老旧的命令行遍历方式逐一配置每个可配置的选项\n  make oldconfig： 透过已经存在的./.config文件内容，并使用该文件内设定值为默认值，只将新版本核心的新功能列出让用户选择，可以简化核心功能挑选过程。对与升级内核很好选择。\n  make defconfig： 基于内核为目标平台执行提供的“默认”配置进行配置\n  make allyesconfig： 所有选项均回答为”yes”\n  make allnoconfig： 所有选项均回答为”no”\n  "});index.add({'id':3,'href':'/notes/docs/technology/system/','title':"系统",'content':"系统 #  "});index.add({'id':4,'href':'/notes/docs/technology/system/Basic/','title':"计算机基础",'content':"计算机基础 #  "});index.add({'id':5,'href':'/notes/docs/technology/system/Basic/constitute/','title':"计算机组成",'content':"计算机组成 #  计算机组成 #  计算机(computer)：一种利用电子学原理，根据一系列指令来对数据进行处理的工具。\n 硬件 #    控制器：负责对程序规定的控制信息进行分析,控制并协调输入,输出操作或内存访问。\n  运算器：负责数据的算术运算和逻辑运算即数据的加工处理。\n  存储器：实现记忆功能的部件用来存放计算程序及参与运算的各种数据。\n  输入设备：实现计算程序和原始数据的输入\n  输出设备：实现计算结果输出\n  图示：\n   软件 #    系统软件：负责管理计算机系统中各种独立的硬件，使得它们可以协调工作，提供基本的功能，并为正在运行的应用软件提供平台。\n  应用软件：为了某种特定的用途而被开发的软件。\n   计算机工作过程 #    用户打开程序\n  系统把程序代码段和数据段送入计算机的内存\n  控制器从存储器中取指令\n  控制器分析,执行指令,为取下一条指令做准备\n  取下一条指令,分析执行,如此重复操作,直至执行完程序中全部指令,便可获得全部指令\n  图示：\n  计算机系统结构 #    "});index.add({'id':6,'href':'/notes/docs/technology/system/Linux/Directory/directoryStructure/','title':"Linux目录结构",'content':"Linux目录结构 #    /boot\n系统启动相关的文件，如内核、initrd，以及grub(bootloader)\n  /dev\n设备文件\n块设备：随机访问，数据块\n字符设备：线性访问，按字符为单位\n设备号：主设备号(major)和次设备号(minor)\n  /etc\n配置文件\n  /home\n用户的家目录，每一个用户的家目录通常默认为/home/USERNAME\n  /root\n管理员的家目录\n  /lib\n库文件\n静态库，.a\n动态库，.dll，.so（shared object）\n  /lib/modules\n内核模块文件\n  /media\n挂载点目录，移动设备\n  /mnt\n挂载点目录，额外的临时文件系统\n  /opt\n可选目录，第三方程序的安装目录\n  /proc\n伪文件系统，内核映射文件\n  /sys\n伪文件系统，跟硬件设备相关的属性映射文件\n  /tmp\n临时文件，/var/tmp\n  /var\n可变化的文件\n  /bin\n可执行文件，用户命令\n  /sbin\n可执行文件，管理命令\n  /usr\nshared，read-only\n/usr/bin\n/usr/sbin\n/usr/lib\n  /usr/local\n第三方软件\n/usr/local/bin\n/usr/local/sbin\n/usr/local/lib\n   "});index.add({'id':7,'href':'/notes/docs/technology/system/Linux/','title':"Linux系统",'content':"Linux系统 #  "});index.add({'id':8,'href':'/notes/docs/technology/system/Linux/Start/start/','title':"启动",'content':"启动过程 #  整个过程基本可以分为POST–\u0026gt;BIOS–\u0026gt;MBR(GRUB)–\u0026gt;Kernel–\u0026gt;Init–\u0026gt;Runlevel。\n  详解 #    BIOS\nBIOS(Basic Input/Output System)，基本输入输出系统，该系统存储于主板的ROM芯片上。开机时，会最先读取该系统，然后会有一个加电自检过程，若没有异常就开始加载BIOS程序到内存当中。BIOS主要的一个功能就是存储了磁盘的启动顺序，BIOS会按照启动顺序去查找第一个磁盘头的MBR信息，并加载和执行MBR中的Bootloader程序，若第一个磁盘不存在MBR，则会继续查找第二个磁盘，一旦BootLoader程序被检测并加载内存中，BIOS就将控制权交接给了BootLoader程序。\n  MBR\nMBR(Master Boot Record)，主引导记录，MBR存储于磁盘的头部，大小为512bytes，其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。\n  GRUB\nGRUB(Grand Unified Bootloader)，多系统启动程序，其执行过程可分为三个步骤：\n  Stage1\n这个其实就是MBR，它的主要工作就是查找并加载第二段Bootloader程序(stage2)，但系统在没启动时，MBR根本找不到文件系统，也就找不到stage2所存放的位置，因此，就有了stage1_5\n  Stage1_5\n该步骤就是为了识别文件系统\n  Stage2\nGRUB程序会根据/boot/grub/grub.conf文件查找Kernel的信息，然后开始加载Kernel程序，当Kernel程序被检测并在加载到内存中，GRUB就将控制权交接给了Kernel程序。\nPS：实际上这个步骤/boot还没被挂载，GRUB直接识别grub所在磁盘的文件系统，所以实际上应该是/grub/grub.conf文件，该配置文件的信息如下：\ngrub.conf:\n #boot=/dev/sda default=0 #设定默认启动的title的编号，从0开始 timeout=5 #等待用户选择的超时时间 splashimage=(hd0,0)/boot/grub/splash.xpm.gz #GRUB的背景图片 hiddenmenu #隐藏菜单 title CentOS (2.6.18-194.el5PAE) #内核标题 root (hd0,0) #内核文件所在的设备 kernel /vmlinuz-2.6.18-194.el5PAE ro root=LABEL=/ #内核文件路径以及传递给内核的参数 initrd /initrd-2.6.18-194.el5PAE.img #ramdisk文件路径      Kernel\nKernel，内核，Kernel是Linux系统最主要的程序，实际上，Kernel的文件很小，只保留了最基本的模块，并以压缩的文件形式存储在硬盘中，当GRUB将Kernel读进内存，内存开始解压缩内核文件。讲内核启动，应该先讲下initrd这个文件，\ninitrd(Initial RAM Disk)，它在stage2这个步骤就被拷贝到了内存中，这个文件是在安装系统时产生的，是一个临时的根文件系统(rootfs)。因为Kernel为了精简，只保留了最基本的模块，因此，Kernel上并没有各种硬件的驱动程序，也就无法识rootfs所在的设备，故产生了initrd这个文件，该文件装载了必要的驱动模块，当Kernel启动时，可以从initrd文件中装载驱动模块，直到挂载真正的rootfs，然后将initrd从内存中移除。\nKernel会以只读方式挂载根文件系统，当根文件系统被挂载后，开始装载第一个进程(用户空间的进程)，执行/sbin/init，之后就将控制权交接给了init程序。\n  Init\ninit，初始化，顾名思义，该程序就是进行OS初始化操作，实际上是根据/etc/inittab(定义了系统默认运行级别)设定的动作进行脚本的执行，第一个被执行的脚本为/etc/rc.d/rc.sysinit，这个是真正的OS初始化脚本，其任务如下：\n  激活udev和selinux;\n  根据/etc/sysctl.conf文件，来设定内核参数;\n  设定系统时钟;\n  装载硬盘映射;\n  启用交换分区;\n  设置主机名;\n  根文件系统检测，并以读写方式重新挂载根文件系统;\n  激活RAID和LVM设备;\n  启用磁盘配额;\n  根据/etc/fstab，检查并挂载其他文件系统;\n  清理过期的锁和PID文件\n  执行完后，根据配置的启动级别，执行对应目录底下的脚本，最后执行/etc/rc.d/rc.local这个脚本，至此，系统启动完成。   Runlevel\nrunlevel，运行级别，不同的级别会启动的服务不一样，init会根据定义的级别去执行相应目录下的脚本，Linux的启动级别分为以下几种：\n0：关机模式\n1：单一用户模式(直接以管理员身份进入)\n2：多用户模式（无网络）\n3：多用户模式（命令行）\n4：保留\n5：多用户模式（图形界面）\n6：重启\n在不同的运行级别下，/etc/rc.d/rc这个脚本会分别执行不同目录下的脚本：\nRunlevel 0 – /etc/rc.d/rc0.d/\nRunlevel 1 – /etc/rc.d/rc1.d/\nRunlevel 2 – /etc/rc.d/rc2.d/\nRunlevel 3 – /etc/rc.d/rc3.d/\nRunlevel 4 – /etc/rc.d/rc4.d/\nRunlevel 5 – /etc/rc.d/rc5.d/\nRunlevel 6 – /etc/rc.d/rc6.d/\n这些目录下的脚本只有K和S开头的文件，K开头的文件为开机需要执行关闭的服务，S开头的文件为开机需要执行开启的服务。\n  "});index.add({'id':9,'href':'/notes/docs/technology/system/Basic/fileSystem/','title':"文件系统",'content':"文件系统 #  文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）。\n概念 #  文件系统是一种用于向用户提供底层数据访问的机制。它将设备中的空间划分为特定大小的块（或者称为簇），一般每块512字节。数据存储在这些块中，大小被修正为占用整数个块。由文件系统软件来负责将这些块组织为文件和目录，并记录哪些块被分配给了哪个文件，以及哪些块没有被使用。\n EXT2文件系统 #  EXT2文件系统是Linux底下最常用的文件系统。其结构如下：\n  Boot Sector\n启动扇区，这个启动扇区可以安装启动管理程序， 这是个非常重要的设计，因为如此一来我们就能够将不同的启动管理程序安装到个别的文件系统最前端，而不用覆盖整颗硬盘唯一的MBR.\n  Block Group\n  Super Block\n记录整个filesystem相关信息\n  Group Descriptions\n描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 (superblock, bitmap, inodemap, data block) 分别介于哪一个 block 号码之间\n  Block Bitmap\n记录使用和未使用的block号码\n  Inode Bitmap\n记录使用和未使用的inode号码\n  Inode Table\n  Data Blocks\n数据块，实际存储数据的地方\n      Inode Table #  inode是ext2文件系统的基本构建块，每个文件和目录都有唯一一个inode。其机构如下：\n  Mode\n存取模式信息(read/write/excute)\n  Owner info\n拥有者与群组信息\n  Size\n文件的容量\n  Timestamps\n  创建或状态改变的时间(ctime)\n  最近一次的读取时间(atime)\n  最近修改的时间(mtime)\n    Direct Blocks\n12个直接指向block号码\n  Indirect Blocks\n间接指向，记录block号码的记录区\n  Double Indirect\n双间接指向\n  Triple Indirect\n三间接指向\n    Super Block #  Super Block是记录整个filesystem相关信息的地方，包括以下：\n  Magic Number\n  Revision Level\n  Mount Count and Maximum Mount Count\n  Block Group Number\n  Block Size\n  Blocks per Group\n  Free Blocks\n  Free Inodes\n  First Inode\n   目录和文件 #    目录\n当我们在 Linux 下的 ext2 文件系统创建一个目录时， ext2 会分配一个 inode 与至少一块 block 给该目录。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码； 而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。\n  文件\n我们在 Linux 下的 ext2 创建一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件。\n  "});index.add({'id':10,'href':'/notes/docs/technology/network/','title':"网络",'content':"网络 #  "});index.add({'id':11,'href':'/notes/docs/technology/system/Application/','title':"应用",'content':"应用 #  "});index.add({'id':12,'href':'/notes/docs/technology/system/Basic/operatingSystem/','title':"操作系统",'content':"操作系统 #  操作系统(operating system)：是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。\n 结构 #    驱动程序：最底层的、直接控制和监视各类硬件的部分，它们的职责是隐藏硬件的具体细节，并向其他部分提供一个抽象的、通用的接口。\n  内核：操作系统之最内核部分，通常运行在最高特权级，负责提供基础性、结构性的功能。\n  函数库(接口库)：是一系列特殊的程序库，它们职责在于把系统所提供的基本服务包装成应用程序所能够使用的编程接口（API），是最靠近应用程序的部分。\n  外围：所谓外围，是指操作系统中除以上三类以外的所有其他部分，通常是用于提供特定高级服务的部件。\n  图示：\n  Linux系统架构： #    功能 #  操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。以现代标准而言，一个标准PC的操作系统应该提供以下的功能：\n  进程管理（Processing management）\n  内存管理（Memory management）\n  文件系统（File system）\n  网络通信（Networking）\n  安全机制（Security）\n  用户界面（User interface）\n  驱动程序（Device drivers）\n  "});index.add({'id':13,'href':'/notes/docs/technology/program/','title':"编程",'content':"编程 #  "});index.add({'id':14,'href':'/notes/docs/technology/system/Linux/GuideBook/','title':"操作指南",'content':"玩转Linux #     CPU\n   内存\n   磁盘\n   系统\n   网络\n   权限\n   文件\n   文本\n   IPMI\n   RAID\n    "});index.add({'id':15,'href':'/notes/docs/technology/database/','title':"数据库",'content':"数据库 #  "});index.add({'id':16,'href':'/notes/docs/technology/cloud/','title':"云原生",'content':"云原生 #  "});index.add({'id':17,'href':'/notes/docs/technology/bigdata/','title':"大数据",'content':"大数据 #  "});index.add({'id':18,'href':'/notes/docs/technology/security/','title':"安全",'content':"安全 #  "});index.add({'id':19,'href':'/notes/docs/technology/tool/','title':"工具",'content':"工具 #  "});index.add({'id':20,'href':'/notes/docs/technology/other/','title':"其他",'content':"其他 #  "});index.add({'id':21,'href':'/notes/docs/technology/bigdata/Basic/','title':"Basic",'content':"大数据基础 #  ##分布式系统\n分布式系统是独立计算机的集合，作为单个计算机对系统用户显示。 分布式系统是一种模型，其中位于联网计算机上的组件通过传递消息来通信和协调他们的动作，组件彼此交互以实现共同目标。\n ##分布式计算\n###优势\n###劣势\n ##分布式系统设计\n协调服务 #    Name service\n  Locking\n  Synchronization\n  Configuration management\n  Leader election\n   "});index.add({'id':22,'href':'/notes/docs/technology/bigdata/Kafka/','title':"Kafka",'content':"Kafka #  "});index.add({'id':23,'href':'/notes/docs/technology/bigdata/Kafka/architecture/','title':"Architecture",'content':"kafka架构 #  "});index.add({'id':24,'href':'/notes/docs/technology/bigdata/Kafka/deploy/','title':"Deploy",'content':""});index.add({'id':25,'href':'/notes/docs/technology/bigdata/Kafka/optimization/','title':"Optimization",'content':""});index.add({'id':26,'href':'/notes/docs/technology/bigdata/Zookeeper/','title':"Zookeeper",'content':"Zookeeper #  ZooKeeper是用于维护配置信息，命名，提供分布式同步和提供组服务的集中式服务。\n    架构\n   部署\n   优化\n   "});index.add({'id':27,'href':'/notes/docs/technology/bigdata/Zookeeper/architecture/','title':"Architecture",'content':"Zookeeper架构 #  "});index.add({'id':28,'href':'/notes/docs/technology/bigdata/Zookeeper/deploy/','title':"Deploy",'content':"Zookeeper部署 #  单机环境搭建 #    下载安装包\n wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz tar -zxvf zookeeper-3.4.10.tar.gz mv zookeeper-3.4.10 zookeeper    修改配置文件\n #vim zookeeper/conf/zoo.cfg tickTime=2000 initLimit=5 syncLimit=2 dataDir=/cache1/zookeeper/data #数据目录 clientPort=2181 #服务端口    配置日志保存目录\n #修改zookeeper/conf/log4j.properties文件 zookeeper.root.logger=INFO, ROLLINGFILE zookeeper.log.dir=/cache1/zookeeper/logs zookeeper.log.file=zookeeper.log #修改zookeeper/bin/zkEnv.sh if [ \u0026quot;x${ZOO_LOG_DIR}\u0026quot; = \u0026quot;x\u0026quot; ] then ZOO_LOG_DIR=\u0026quot;/cache1/zookeeper/logs/\u0026quot; fi if [ \u0026quot;x${ZOO_LOG4J_PROP}\u0026quot; = \u0026quot;x\u0026quot; ] then ZOO_LOG4J_PROP=\u0026quot;INFO,ROLLINGFILE\u0026quot; fi    启动服务\n cd zookeeper/bin \u0026amp;\u0026amp; ./zkServer.sh start     集群环境搭建 #    机器准备\n #3台设备 192.168.1.21 192.168.1.22 192.168.1.33    系统环境准备\n #/etc/hosts文件增加以下内容 192.168.1.21 zoo1 192.168.1.22 zoo2 192.168.1.33 zoo3    下载安装包\n wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz tar -zxvf zookeeper-3.4.10.tar.gz mv zookeeper-3.4.10 zookeeper    修改配置文件\n #vim zookeeper/conf/zoo.cfg tickTime=2000 initLimit=5 syncLimit=2 dataDir=/cache1/zookeeper/data #数据目录 clientPort=2181 #服务端口 server.1=zoo1:2888:3888 #server.x的x与myid文件的值匹配 server.2=zoo2:2888:3888 #zoo1表示hostname server.3=zoo3:2888:3888 #2888是followers用来连接leader，3888用于leader的选举    各机器创建myid文件\n #zoo1 echo 1 \u0026gt; /cache1/zookeeper/data/myid #zoo2 echo 2 \u0026gt; /cache1/zookeeper/data/myid #zoo3 echo 3 \u0026gt; /cache1/zookeeper/data/myid    各机器启动服务\n cd zookeeper/bin \u0026amp;\u0026amp; ./zkServer.sh start    "});index.add({'id':29,'href':'/notes/docs/technology/bigdata/Zookeeper/optimization/','title':"Optimization",'content':"Zookeeper优化 #  "});index.add({'id':30,'href':'/notes/docs/technology/cloud/Ansible/ansible/','title':"Ansible",'content':"Ansible #  安装 #    安装ansible\npip install ansible    测试\necho \u0026quot;127.0.0.1\u0026quot; \u0026gt; ~/ansible_hosts export ANSIBLE_INVENTORY=~/ansible_hosts ansible all -m ping --ask-pass    Inventory #    主机和组\nansible_hosts 文件\n[group1] host1 host2 [group2] host3 host4 ssh选项 ansible_port=5555(默认22) ansible_host=172.16.0.101 ansible_user=root(默认root) ansible_connection=ssh(默认ssh) ansible_ssh_pass= host变量 http_port=80 maxRequestsPerChild=808 group变量 [group1:vars] ansible_port=33 group包含group [group3:children] group1 group2     命令行 #  ansible \u0026lt;server_name\u0026gt; -m \u0026lt;module_name\u0026gt; -a \u0026lt;arguments\u0026gt;   配置文件 #  略\nPlaybook #  Playbook是Ansible的配置，部署和编排语言，他们可以描述您希望远程系统执行的策略，或一般IT流程中的一组步骤。\n一个playbook案例\n--- - hosts: webservers vars: http_port: 80 max_clients: 200 remote_user: root tasks: - name: ensure apache is at the latest version yum: name=httpd state=latest - name: write the apache config file template: src=/srv/httpd.j2 dest=/etc/httpd.conf notify: - restart apache - name: ensure apache is running (and enable it at boot) service: name=httpd state=started enabled=yes handlers: - name: restart apache service: name=httpd state=restarted   roles #   案例 #     tomcat\n   tengine\n   zookeeper\n   kafka\n  "});index.add({'id':31,'href':'/notes/docs/technology/cloud/Elk/elk/','title':"Elk",'content':"ELK Stack #  ELK是一个实现可靠，安全地从任何来源，任何格式和 实时搜索，分析和可视化的工具\n 架构 #  ELK Stack主要由四个组件组成：\n  Filebeat: 从客户端收集日志并传送给Logstash\n  Logstash: 用于处理传入日志并传送给ElasticSearch\n  ElasticSearch: 存储日志并供Kibana查询\n  Kibana: 用于搜索和可视化日志的Web界面\n    使用 #     安装\n  日志解析\n   "});index.add({'id':32,'href':'/notes/docs/technology/cloud/Elk/elkinstall/','title':"Elkinstall",'content':"ELK安装 #  环境准备 #    CentOS 7\n  Java 8\n   ELK安装 #    配置ELK的repo文件\nrpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch #vim /etc/yum.repo.d/elk.repo [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md    ElasticSearch\n#install yum install elasticsearch /bin/systemctl daemon-reload /bin/systemctl enable elasticsearch.service systemctl start elasticsearch.service #Test curl http://localhost:9200/    Kibana\n#install yum install kibana /bin/systemctl daemon-reload /bin/systemctl enable kibana.service #vim /etc/kibana/kibana.yml server.host: 0.0.0.0    LogStash\n#install yum install logstash /bin/systemctl start logstash.service    Filebeat\n#install yum -y install filebeat     配置 #    配置hosts\n#vim /etc/hosts 192.168.19.26 elk.cctest.com    生成SSL证书\ncd /etc/pki/tls openssl req -subj '/CN=elk.cctest.com/' -x509 -days 3650 -batch -nodes -newkey rsa:2048 -keyout private/logstash-forwarder.key -out certs/logstash-forwarder.crt    logstash配置\n#vim /etc/logstash/conf.d/02-beats-input.conf input { beats { port =\u0026gt; 5044 ssl =\u0026gt; true ssl_certificate =\u0026gt; \u0026quot;/etc/pki/tls/certs/logstash-forwarder.crt\u0026quot; ssl_key =\u0026gt; \u0026quot;/etc/pki/tls/private/logstash-forwarder.key\u0026quot; } } #vim /etc/logstash/conf.d/10-log-filter.conf filter { grok { match =\u0026gt; { \u0026quot;message\u0026quot; =\u0026gt; \u0026quot;%{COMBINEDAPACHELOG}\u0026quot; } } geoip { source =\u0026gt; \u0026quot;clientip\u0026quot; } } #vim /etc/logstash/conf.d/30-elasticsearch-output.conf output { elasticsearch { hosts =\u0026gt; [\u0026quot;localhost:9200\u0026quot;] } } #重启logstash /bin/systemctl restart logstash.service    filebeat配置\n#vim /etc/filebeat/filebeat.yml filebeat.prospectors: - type: log enabled: true paths: - /var/log/messages* filebeat.config.modules: path: ${path.config}/modules.d/*.yml reload.enabled: false setup.template.settings: index.number_of_shards: 3 output.logstash: hosts: [\u0026quot;elk.cctest.com:5044\u0026quot;] ssl.certificate_authorities: [\u0026quot;/etc/pki/tls/certs/logstash-forwarder.crt\u0026quot;] # systemctl start filebeat    浏览器打开kibana\nhttp://localhost:5601/     "});index.add({'id':33,'href':'/notes/docs/technology/cloud/Kubernetes/cluster/','title':"Cluster",'content':"手动部署kubernetes高可用集群 #  环境准备 #  软件 #    etcd\n  docker\n  kubernetes\n  kubelet\n  kube-proxy\n  kube-apiserver\n  kube-controller-manager\n  kube-scheduler\n     软件准备 #     Docker安装\n  软件下载\n wget https://storage.googleapis.com/kubernetes-release/release/v1.6.9/kubernetes.tar.gz tar -zxvf kubernetes.tar.gz ./kubernetes/cluster/get-kube-binaries.sh wget https://github.com/coreos/etcd/releases/download/v3.2.6/etcd-v3.2.6-linux-amd64.tar.gz     etcd高可用集群搭建 #  安装cfssl #  go get -u github.com/cloudflare/cfssl/cmd/...  将在$GOPATH/bin下安装cfssl, cfssjosn, mkbundle等工具\nCA证书和私钥 #  创建ca-config.json:\n{ \u0026quot;signing\u0026quot;: { \u0026quot;default\u0026quot;: { \u0026quot;expiry\u0026quot;: \u0026quot;87600h\u0026quot; }, \u0026quot;profiles\u0026quot;: { \u0026quot;frognew\u0026quot;: { \u0026quot;usages\u0026quot;: [ \u0026quot;signing\u0026quot;, \u0026quot;key encipherment\u0026quot;, \u0026quot;server auth\u0026quot;, \u0026quot;client auth\u0026quot; ], \u0026quot;expiry\u0026quot;: \u0026quot;87600h\u0026quot; } } } }  创建CA证书签名请求配置ca-csr.json:\n{ \u0026quot;CN\u0026quot;: \u0026quot;frognew\u0026quot;, \u0026quot;key\u0026quot;: { \u0026quot;algo\u0026quot;: \u0026quot;rsa\u0026quot;, \u0026quot;size\u0026quot;: 2048 }, \u0026quot;names\u0026quot;: [ { \u0026quot;C\u0026quot;: \u0026quot;CN\u0026quot;, \u0026quot;ST\u0026quot;: \u0026quot;BeiJing\u0026quot;, \u0026quot;L\u0026quot;: \u0026quot;BeiJing\u0026quot;, \u0026quot;O\u0026quot;: \u0026quot;frognew\u0026quot;, \u0026quot;OU\u0026quot;: \u0026quot;cloudnative\u0026quot; } ] }  使用cfssl生成CA证书和私钥：\ncfssl gencert -initca ca-csr.json | cfssljson -bare ca  ca-key.pem和ca.pem需要保存，后边会用到\netcd证书和私钥 #  创建etcd证书签名请求配置etcd-csr.json:\n{ \u0026quot;CN\u0026quot;: \u0026quot;cctest\u0026quot;, \u0026quot;hosts\u0026quot;: [ \u0026quot;127.0.0.1\u0026quot;, \u0026quot;192.168.19.11\u0026quot;, \u0026quot;192.168.19.12\u0026quot;, \u0026quot;192.168.19.13\u0026quot;, \u0026quot;node1\u0026quot;, \u0026quot;node2\u0026quot;, \u0026quot;node3\u0026quot; ], \u0026quot;key\u0026quot;: { \u0026quot;algo\u0026quot;: \u0026quot;rsa\u0026quot;, \u0026quot;size\u0026quot;: 2048 }, \u0026quot;names\u0026quot;: [ { \u0026quot;C\u0026quot;: \u0026quot;CN\u0026quot;, \u0026quot;ST\u0026quot;: \u0026quot;BeiJing\u0026quot;, \u0026quot;L\u0026quot;: \u0026quot;BeiJing\u0026quot;, \u0026quot;O\u0026quot;: \u0026quot;cctest\u0026quot;, \u0026quot;OU\u0026quot;: \u0026quot;cloudnative\u0026quot; } ] }  生成etcd的证书和私钥\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=frognew etcd-csr.json | cfssljson -bare etcd  etcd安装 #  将ca.pem, etcd-key.pem, etcd.pem拷贝到各节点的/etc/etcd/ssl目录中\ncp ca.pem /etc/etcd/ssl cp etcd*.pem /etc/etcd/ssl  解压缩etcd-v3.2.6-linux-amd64.tar.gz，拷贝可执行文件\ntar -zxvf etcd-v3.2.6-linux-amd64.tar.gz cp etcd-v3.2.6-linux-amd64/etcd* /usr/bin/  创建etcd的systemd unit文件\nexport ETCD_NAME=node1 export INTERNAL_IP=192.168.19.11 cat \u0026gt; /usr/lib/systemd/system/etcd.service \u0026lt;\u0026lt;EOF [Unit] Description=etcd server After=network.target After=network-online.target Wants=network-online.target [Service] Type=notify WorkingDirectory=/var/lib/etcd/ EnvironmentFile=-/etc/etcd/etcd.conf ExecStart=/usr/bin/etcd \\ --name ${ETCD_NAME} \\ --cert-file=/etc/etcd/ssl/etcd.pem \\ --key-file=/etc/etcd/ssl/etcd-key.pem \\ --peer-cert-file=/etc/etcd/ssl/etcd.pem \\ --peer-key-file=/etc/etcd/ssl/etcd-key.pem \\ --trusted-ca-file=/etc/etcd/ssl/ca.pem \\ --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \\ --initial-advertise-peer-urls https://${INTERNAL_IP}:2380 \\ --listen-peer-urls https://${INTERNAL_IP}:2380 \\ --listen-client-urls https://${INTERNAL_IP}:2379,https://127.0.0.1:2379 \\ --advertise-client-urls https://${INTERNAL_IP}:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster node1=https://192.168.19.11:2380,node2=https://192.168.19.12:2380,node3=https://192.168.19.13:2380 \\ --initial-cluster-state new \\ --data-dir=/var/lib/etcd Restart=on-failure RestartSec=5 LimitNOFILE=65536 [Install] WantedBy=multi-user.target EOF  启动etcd #  各节点启动etcd服务\nsystemctl daemon-reload systemctl enable etcd systemctl start etcd systemctl status etcd  集群检查：\netcdctl \\ --ca-file=/etc/etcd/ssl/ca.pem \\ --cert-file=/etc/etcd/ssl/etcd.pem \\ --key-file=/etc/etcd/ssl/etcd-key.pem \\ --endpoints=https://node1:2379,https://node2:2379,https://node3:2379 \\ cluster-health   Kubernetes Master 集群搭建 #  "});index.add({'id':34,'href':'/notes/docs/technology/cloud/Kubernetes/kubeadm/','title':"Kubeadm",'content':"kubeadm快速部署kubernetes #  环境搭建 #    环境准备\n #放开防火墙限制 systemctl stop firewalld systemctl disable firewalld #更改内核参数 echo 1 \u0026gt; /proc/sys/net/bridge/bridge-nf-call-ip6tables echo 1 \u0026gt; /proc/sys/net/bridge/bridge-nf-call-iptables #禁用SELINUX setenforce 0    Docker安装\n参考 Docker安装\n #开启iptables filter表中FOWARD链(Docker1.3开始已被禁用) iptables -P FORWARD ACCEPT #/etc/docker/daemon.json增加配置 { \u0026quot;exec-opts\u0026quot;: [\u0026quot;native.cgroupdriver=systemd\u0026quot;] } #重启Docker systemctl restart docker.service    Kubeadm安装\n #添加repo配置 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg EOF #安装kubeadm,kubelet,kubectl yum install -y kubelet kubeadm kubectl systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet     Master node 初始化 #    init\n kubeadm init --pod-network-cidr=10.244.0.0/16 #记录join值 kubeadm join --token \u0026lt;token\u0026gt; \u0026lt;master-ip\u0026gt;:\u0026lt;master-port\u0026gt; #配置KUBECONFIG环境参数 export KUBECONFIG=/etc/kubernetes/admin.conf    Pod Network安装\n mkdir -p ~/k8s/ wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel-rbac.yml wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml kubectl create -f kube-flannel-rbac.yml kubectl apply -f kube-flannel.yml     Node 加入 Master #  kubeadm join --token \u0026lt;token\u0026gt; \u0026lt;master-ip\u0026gt;:\u0026lt;master-port\u0026gt;   kubectl操作 #  #获取组件状态 kubectl get cs #查看pod状态 kubectl get pod --all-namespaces -o wide #部署应用  "});index.add({'id':35,'href':'/notes/docs/technology/cloud/Kubernetes/kubernetes/','title':"Kubernetes",'content':"Kubernetes #  k8s是一个开源系统，它可以被用于自动部署，扩展和管理容器化（containerized）应用程序。\n 架构 #    Master #    etcd\n  API Server\n  Scheduler\n  Controller manager\n  Node #    Kubelet\n  Kube-proxy\n  cAdvisor\n   安装 #     Kubeadm\n基于kubeadm工具部署kubernetes,包含Master和Node。(测试版本，不适用于生产环境)\n   Master-Cluster\n基于kubernetes安装包部署kubernetes集群环境。\n   Objects #  basic objects #    Pod\n  Service\n  Volume\n  Namespace\n  controllers #  基于basic objects，提供额外的功能。\n  ReplicaSet\n  Deployment\n  StatefulSet\n  DaemonSet\n  Job\n   Control Plane #    Kubernetes Master\n  Kubernetes Nodes\n  "});index.add({'id':36,'href':'/notes/docs/technology/database/Mysql/cluster/','title':"Cluster",'content':"MySQL Cluster #  Master-Slave #  Master配置 #  /etc/my.cnf 增加配置\n[mysqld] server-id=1 log-bin=/cache1/mysql/log/mysql-bin.log #忽略系统库 binlog-ignore-db=mysql binlog-ignore-db=information_schema binlog-ignore-db=performance_schema  Replication 帐号创建\nmysql\u0026gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%' IDENTIFIED BY 'slave@2017';  导出数据到从库\nmysql\u0026gt; USE newdatabase; mysql\u0026gt; FLUSH TABLES WITH READ LOCK; mysql\u0026gt; SHOW MASTER STATUS; +------------------+----------+--------------+---------------------------------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+---------------------------------------------+-------------------+ | mysql-bin.000002 | 754 | | mysql,information_schema,performance_schema | | +------------------+----------+--------------+---------------------------------------------+-------------------+ 1 row in set (0.00 sec) shell\u0026gt; mysqldump -u root -p --opt newdatabase \u0026gt; newdatabase.sql mysql\u0026gt; UNLOCK TABLES;  Slave配置 #  /etc/my.cnf增加配置\n[mysqld] server-id=2 log-bin=/cache1/mysql/log/mysql-bin.log #忽略系统库 binlog-ignore-db=mysql binlog-ignore-db=information_schema binlog-ignore-db=performance_schema  导入数据\nmysql\u0026gt; CREATE DATABASE newdatabase; shell\u0026gt; mysql -u root -p newdatabase \u0026lt; /path/to/newdatabase.sql  配置主服务器\nmysql\u0026gt; CHANGE MASTER TO MASTER_HOST='master_host_name',MASTER_USER='repl',MASTER_PASSWORD='slave@2017',MASTER_LOG_FILE='mysql-bin.000002',MASTER_LOG_POS=754; mysql\u0026gt; START SLAVE; mysql\u0026gt; SHOW SLAVE STATUS\\G;  从库切换成主库\nmysql\u0026gt; SHOW PROCESSLIST; mysql\u0026gt; RESET MASTER;   Master-Master #  Master1，Master2配置 #  /etc/my.cnf 增加配置\n[mysqld] server-id=1 (Master2配置成2) log-bin=/cache1/mysql/log/mysql-bin.log #忽略系统库 binlog-ignore-db=mysql binlog-ignore-db=information_schema binlog-ignore-db=performance_schema  Replication 帐号创建\nmysql\u0026gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%' IDENTIFIED BY 'slave@2017';  Master1查看本机Master状态 #  mysql\u0026gt; SHOW MASTER STATUS; +------------------+----------+--------------+---------------------------------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+---------------------------------------------+-------------------+ | mysql-bin.000002 | 754 | | mysql,information_schema,performance_schema | | +------------------+----------+--------------+---------------------------------------------+-------------------+ 1 row in set (0.00 sec)  Master2查看本机Master状态 #  mysql\u0026gt; show master status; +------------------+----------+--------------+---------------------------------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+---------------------------------------------+-------------------+ | mysql-bin.000001 | 915 | | mysql,information_schema,performance_schema | | +------------------+----------+--------------+---------------------------------------------+-------------------+ 1 row in set (0.00 sec)  Master1配置成Master2的从库 #  mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='master2',MASTER_USER='repl',MASTER_PASSWORD='slave@2017',MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=915; mysql\u0026gt; START SLAVE; mysql\u0026gt; SHOW SLAVE STATUS\\G;  Master2配置成Master1的从库 #  mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='master_host_name',MASTER_USER='repl',MASTER_PASSWORD='slave@2017',MASTER_LOG_FILE='mysql-bin.000002',MASTER_LOG_POS=754; mysql\u0026gt; START SLAVE; mysql\u0026gt; SHOW SLAVE STATUS\\G;   "});index.add({'id':37,'href':'/notes/docs/technology/database/Mysql/install/','title':"Install",'content':"Mysql 安装 #  源码编译安装 #  准备 #    CMake(build framework)\nyum -y install cmake    GNU make(make program)\nyum -y install make    GCC(ANSI C++ complier)\nyum -y install gcc gcc-c++    Boost C++ libraries\n  ncurses library\nyum -y install ncurses ncurses-devel    Perl(run test scripts)\nyum -y install perl     安装 #    创建用户组\nshell\u0026gt; groupadd mysql shell\u0026gt; useradd -r -g mysql -s /bin/false mysql    编译安装\nshell\u0026gt; tar -zxvf mysql-VERSION.tar.gz shell\u0026gt; cd mysql-VERSION shell\u0026gt; mkdir bld shell\u0026gt; cd bld shell\u0026gt; cmake .. -DDOWNLOAD_BOOST=1 -DWITH_BOOST=/usr/local/src -DCMAKE_INSTALL_PREFIX=/cache1/mysql -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci shell\u0026gt; make shell\u0026gt; make install    数据初始化\n  /etc/my.cnf文件配置\n[client] port=3306 socket=/tmp/mysql.sock [mysqld] bind-address=0.0.0.0 port=3306 socket=/tmp/mysql.sock datadir=/cache1/mysql/data symbolic-links=0 log-error=/cache1/mysql/log/mysqld.log pid-file=/cache1/mysql/log/mysqld.pid  数据初始化\nshell\u0026gt; cd /cache1/mysql shell\u0026gt; mkdir data log shell\u0026gt; chown -R mysql:mysql data shell\u0026gt; chown -R mysql:mysql log shell\u0026gt; bin/mysqld --initialize --user=mysql shell\u0026gt; cp support-files/mysql.service /etc/init.d/mysqld shell\u0026gt; /etc/init.d/mysqld start shell\u0026gt; mysql -uroot -p mysql\u0026gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password'; mysql\u0026gt; SET PASSWORD = PASSWORD('your_new_password'); mysql\u0026gt; SELECT User, Host, HEX(authentication_string) FROM mysql.user;  "});index.add({'id':38,'href':'/notes/docs/technology/database/Mysql/mysql/','title':"Mysql",'content':"Mysql #     Install guide\n   Cluster\n  "});index.add({'id':39,'href':'/notes/docs/technology/database/PostgreSQL/postgresql/','title':"Postgresql",'content':"PostgreSQL #  "});index.add({'id':40,'href':'/notes/docs/technology/database/Redis/cluster/','title':"Cluster",'content':"集群 #  集群搭建 #    Redis安装\nwget http://download.redis.io/releases/redis-4.0.1.tar.gz    基础配置\n#除端口外，配置统一 #common port 6379 pidfile /cache1/redis/6379/redis_6379.pid loglevel notice logfile \u0026quot;/cache1/redis/6379/redis_6379.log\u0026quot; dir /cache1/redis/6379 protected-mode no #rdb save 7200 1000 rdbcompression yes rdbchecksum yes dbfilename dump.rdb #aof appendonly yes appendfilename \u0026quot;appendonly.aof\u0026quot; #cluster cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000    redis集群架构\n192.168.88.1:6379(master) 192.168.88.2:6379(slave) 192.168.88.2:6378(master) 192.168.88.3:6378(slave) 192.168.88.3:6377(master) 192.168.88.1:6377(slave)    启动redis\ncd $PATH redis-server redis-6379.conf \u0026amp;    集群管理器安装\n#安装ruby tar -zxf ruby-2.4.1.tar.gz cd ruby-2.4.1 ./configure make \u0026amp;\u0026amp; make install #安装gem tar -zxf rubygems-2.6.12.tgz cd rubygems-2.6.12/ ruby setup.rb --no-rdoc --no-ri #安装redisgem gem install redis    集群建立\ncd /usr/local/src/redis-4.0.1/ src/redis-trib.rb create --replicas 1 192.168.88.1:6379 192.168..88.2:6378 192.168.88.3:6377 192.168.88.2:6379 192.168.88.3:6378 192.168.88.1:6377    简单测试\nredis-cli -c -h 192.168.88.1 -p 6379 cluster nodes    集群分片\nsrc/redis-trib.rb reshard 192.168.88.1:6379    添加节点\nsrc/redis-trib.rb add-node 192.168.88.1:6376 172.16.88.1:6379 src/redis-trib.rb add-node --slave --master-id xxxx 192.168.88.1:6376 192.168.88.1:6379    从节点更改\nredis-cli -c -p 6377 cluster replicate \u0026lt;master-node-id\u0026gt;     集群优化 #    配置文件优化\n  集群配置密码\n#redis.conf配置文件 requirepass 123456 masterauth 123456 #集群管理客户端 #/usr/local/lib/ruby/gems/2.4.1/gems/redis-3.3.3/lib/redis/client.rb password =\u0026gt; \u0026quot;123456\u0026quot;    "});index.add({'id':41,'href':'/notes/docs/technology/database/Redis/redis/','title':"Redis",'content':"Redis #    基础\n   集群搭建\n  "});index.add({'id':42,'href':'/notes/docs/technology/hidden/','title':"Hidden",'content':"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "});index.add({'id':43,'href':'/notes/docs/technology/network/Protocol/http/','title':"Http",'content':"HTTP #  HTTP，HyperText Transfer Protocol，超文本传输协议，是一种应用层协议，被广泛应用于互联网。\n "});index.add({'id':44,'href':'/notes/docs/technology/other/BookNotes/bookNotes/','title':"Book Notes",'content':"读书笔记 #     操作系统思考\n   CS50\n   codecademy\n  "});index.add({'id':45,'href':'/notes/docs/technology/other/BookNotes/codecademy/','title':"Codecademy",'content':"codecademy在线学习 #  HTML和CSS学习 #  HTML #  html基本机构 #  \u0026lt;!DOCTYPE html\u0026gt; //向浏览器声明类型 \u0026lt;html\u0026gt; //所有的html代码都要包含在该元素内 \u0026lt;head\u0026gt; //关于网页的信息，如标题 \u0026lt;title\u0026gt;First Web Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; //可见的html代码内容都放在该元素内 \u0026lt;p\u0026gt;Hello,World!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  可见内容 #    标题\nheading\n \u0026lt;h1\u0026gt;head\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;h4\u0026gt; \u0026lt;h5\u0026gt; \u0026lt;h6\u0026gt;    段落\nparagraph\n \u0026lt;p\u0026gt;content\u0026lt;/p\u0026gt;    无序列表\nunodered list, list item\n \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;sub\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;    有序列表\nordered list, list item\n \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;sub\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt;    链接\n链接, href属性，属性提供更多元素内容的有关信息,在元素的开头标签中，由名称和值组成\n \u0026lt;a href=\u0026quot;https://example.com\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;content\u0026lt;/a\u0026gt;  链接属性: target属性指定链接要在新的浏览器打开.\n  图片\nimage\n \u0026lt;img src=\u0026quot;https://example.com/example.jpg\u0026quot; alt=\u0026quot;example\u0026quot; /\u0026gt; alt属性: 描述图像信息    换行\nline breaks\n aaa?\u0026lt;br/\u0026gt;bbb    注释\n   CSS #  CSS是网页开发人员用来在网页上设计HTML内容的语言.\n在html文件中编写css代码\n在head元素中加入style元素\n \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; h2 { font-family: Arial; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt;  在css文件中编写css代码 在html文件链接css文件，放在html文件开头 使用link元素 * href属性 css文件地址 * type属性 描述文件类型 * rel属性 描述css和html文件的关系\n link href=\u0026quot;https://www.codecademy.com/stylesheets/style.css\u0026quot; type=\u0026quot;text/css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt;  color #    foregroud\n前景色是元素出现的颜色，color属性表示前景色 \\\n  background\nbackground-color表示背景色。\n  named colors\n 147 named colors\ncolor: named colors\n  RGB colors\nRGB(Red,Green,Blue) color: rgb(123,20.233)\n  Hex colors\ncolor: #09AA34\n  HSL colors\nHSL(Hue, Saturation, Lightness) color: hsl(182, 20%, 50%)\n  font #    font-family\n更改字体系列，font-family: \u0026ldquo;Courier New\u0026rdquo;;\n  fallback fonts\n当指定的字体不存在时，使用系统预先安装的字体，font-family: fonts-name, serif;\n  font-size\n更改字体大小，font-size: 18px; 三种大小单位：px, em, %;\n  line height\n更改行高，font-height: 1.5em;\n  word spacing\n字间距，word-spacing: 0.3em;\n  letter spacing\n字母间距：letter-spacing: 0.3em;\n  font weight\n更改字体粗细，font-weight: bold;\n  font style\n字体风格，font-style: italic;\n  text transformation\n内容转型: text-transform: uppercase;\n  text alignment\n文本对齐: text-align: right;\n   "});index.add({'id':46,'href':'/notes/docs/technology/other/BookNotes/CS50/','title':"C S50",'content':"CS50学习笔记 #  "});index.add({'id':47,'href':'/notes/docs/technology/other/BookNotes/finacial/','title':"Finacial",'content':"Finanical #  Goal Setting #  Understand How Goals Are Used #    What is a goal?\n  Long term vs Intermediate vs Short term\n  Is a financial goal any different than other goals?\n  SMART Goals #    Specific\n  Measurable\n  Attainable\n  Realistic\n  Time\n  Finanical Goals #    Saving\n  Housing\n  Insurance\n  Retirement\n   Budgeting #  What is a budget #    What is a budget\n A budget is a spending plan Dollars designated for specific areas    Where do the numbers come from?\n Cash flow statement A budget can be changed Review your cash flow statement to find excess or unusual amounts    Types of Budgets #    Written\n  Envelope\n  Mental\n  Develop the Budget #    Take a look at the cash flow statement\n  List all income\n  List the expenses by category\n  Compare income to expenses\n  Fixed or Variable? #    Fixed expenses\n  Variable expenses\n  Adjust variable expenses to keep expenses less than your income\n  Or adjust income to make income cover expenses\n   Credit #  What is credit ? #    What is credit?\n  Consumer credit\n  cost of credit\n  What is the Credit bureau? #   The credit bureau collects and shares your credit information  Credit Score #    Five factors that are considered\n  Payment history\n  Debt\n  Length of credit history\n  Types of credit\n  Inquiries\n    Type of Credit #    Credit card\n  Convenience users vs borrower\n  Bank card or merchant card\n    Unsecured loan\n Depending on your credit, this may or may not be available    Secured loan\n The lender has collateral ,therefore less risk.    Mortgage\n Less risk, but larger amount.    Obtaining the Credit #    Credit card\n Apply for a credit card.    Unsecured loan\n Talk to your financial institution.    Secured loan\n Talk to your financial institution or the company selling the product    Mortgage\n Apply through your financial institution.    Evaluating Credit Worthiness #    Capacity\n  Character\n  Collateral\n  Capital\n  Conditions\n   Insurance #  What is insurance ? #    What is insurance?\n Insurance is all about risk management Insurance is available to prevent financial loss The insurance company assumes the risk for you The individual pays the company a premium    Where do the numbers come from?\n The likelihood of an individual experiencing a loss The potential cost of each loss Based on the concept of large numbers    Risk management terms #    Risk\n An unpredictable chance of loss or injury    Hazard\n Anything that increases the likelihood a loss    Peril\n Anything that causes a loss    Liability\n The legal responsibility for someone else\u0026rsquo;s loss    Areas of Insurance #    Property\n Automobile Home Personal possessions    Liability\n  Health\n  Life\n   Investing #  Common Types of Investments #    Money Market Securities\n  Stock\n  Bonds\n  Mutual Funds\n  Return on Investment #    Dividend or interest\n  Increase(or decrease) in value\n  Risk #    Inflation\n  Interest rate\n  Business failure\n  Market\n  Common Mistakes #    Unrealistic goals\n  Lose sight of the goal\n  Borrowing to invest\n  Taking additional risk to cover previous losses\n  Accepting advice from \u0026ldquo;the expert\u0026rdquo;\n   #  "});index.add({'id':48,'href':'/notes/docs/technology/other/BookNotes/thinkOS/','title':"Think O S",'content':"操作系统思考 #  编译 #   编译语言和解释语言    编译语言\n程序被翻译成机器语言，之后由硬件执行。\n  解释语言\n程序被软件解释器读取并执行。\n  静态类型和动态类型    动态类型\n无需定义变量类型，直到运行时才直到变量类型，解释语言通常支持动态类型。\n  静态类型\n需定义变量类型，编译语言通常限制为静态类型。\n优点：\n  编译时检查，可以更快找到错误。\n  节省空间\n动态语言，变量的名称在程序运行时存储在内存中，并且它们通常可由程序访问。 编译语言，变量的名称只存在编译时，而不是运行时。 编译器为每个变量选择一个位置，并记录这些位置作为所编译程序的一部分。变量的位置被称为“地址”。在运行期间，每个变量的值都存储在它的地址处，但变量的名称完全不会存储。      编译过程    预处理\nC是包含\u0026quot;预处理指令\u0026quot;的几种语言之一，它生效于编译之前。例如，#include 指令使其他文件的源代码插入到指令所在的位置\n  解析\n编译器读取源代码，并构建程序的内部表示，称为\u0026quot;抽象语法树(AST)\u0026quot;。这一阶段的错误检查通常为语法错误。\n  静态检查\n编译器会检查变量和值得类型是否正确，函数调用是否带有正确数量和类型的参数，以及其他。这一阶段的错误检测通常为一些\u0026quot;静态语义\u0026quot;的错误\n  代码生成\n编译器读取程序的内部表示，并生成机器码或字节码\n  链接\n如果程序使用了定义在库中的值或函数，编译器需要找到合适的库并包含所需要的代码。\n  优化\n在这个过程的几个时间点上，编译器可以修改程序来生成运行更快或占用更少空间的代码。\n  目标代码  编译后的程序，目标代码并不是可执行代码，但是它可以链接到可执行文件中。\n汇编代码  编译后的程序，它通常为机器代码的可读形式。\n 预处理\n  理解错误\n   进程 #   抽象和虚拟化    抽象\n抽象是复杂事物的简单表示。\n  虚拟化\n一类非常重要的抽象就是虚拟化，它是创建可取的幻象的过程。\n  隔离  工程最重要的原则之一就是隔离(lsolation)。\n操作系统最重要的目标之一，就是将每个进程和其他进程隔离，使程序员不必考虑每个可能的交互情况。提供这种隔离的软件对象叫做进程(Porcess)。\n进程是表示运行中程序的软件对象。通常一个对象包含数据，并且提供用于操作数据的方法。\n进程正是包含以下数据的对象：\n 程序文本，通常是机器语言的指令序列。 程序相关的数据，包括静态数据（编译时分配）和动态数据，后者包括运行时的栈和堆。 任何等等中的IO状态。 程序的硬件状态，包括存储在寄存器中的数据，状态信息，以及程序计数器，它表示当前执行了哪个指令。  操作系统提供了隔离进程的基本功能：\n 多任务：大多数操作系统有能力在几乎任何时候中断一个进程，保存它的硬件状态，并且在以后恢复它。 虚拟内存：大多数操作系统会创建幻象，每个进程看似拥有独立内存片并且孤立于其他进程。 设备抽象：运行于同一台计算机的进程共享磁盘、网络接口、显卡和其他硬件。   虚拟内存 #   虚拟内存 #   简明信息理论  比特是二进制的数字，也是信息单位。 n个比特可以表示2 ** b个值，一个字节是8个比特，所以它可以存储256个值。\n内存(Memory)和存储器(Storage)  当进程处于运行期间，它的多数数据都放在内存中。内存中的数据容易丢失。单位为GiB代表\u0026quot;gibibyte\u0026rdquo;，相当于2 ** 30字节\n如果进程会读写文件，这些文件通常放在存储器中。存储器的数据可用于长时间存储。单位为GB代表\u0026quot;gigabyte\u0026rdquo;，相当于10 ** 30字节\n地址空间  内存中的每个字节都由一个\u0026quot;物理地址\u0026quot;整数所指定，物理地址的集合叫做物理\u0026quot;地址空间\u0026rdquo;。范围通常为0到N-1，N是内存大小。\n操作系统提供\u0026quot;虚拟内存\u0026rdquo;，程序处理虚拟地址，范围为0到M-1，M是有效虚拟地址的大小。虚拟地址空间的大小取决于操作系统和硬件。\n  32位系统\n虚拟地址是32位的，虚拟地址空间的大小是2 ** 32个字节，或者4GiB\n  64位系统\n虚拟地址是64位的，虚拟地址空间的大小是2 ** 64个字节，或者是4 * 1024 ** 6个字节，16EiB\n  当一个程序读写内存中的值时，它使用虚拟地址。硬件在操作系统的帮助下，在访问主存之前将物理地址翻译成虚拟地址。翻译过程在进程层级上完成，所以两个进程访问相同的虚拟地址，他们所映射的物理地址可能不同。\n虚拟内存是操作系统隔离进程的一种重要途径。\n内存段  一个运行中进程的数据组织为4个段：\n text段：包含程序文本，即程序所组成的机器语言指令。靠近内存\u0026quot;底部\u0026rdquo;，即接近0的地址 static段：包含由编译器所分配的变量，包含全局变量和使用static声明的局部变量。通常刚好在text段上面 stack段：包含运行时栈，它由栈帧组成。每个帧包含函数参数、本地变量以及其他。靠近内存顶部，即接近虚拟地址空间的最大地址。在扩张过程中，它向低地址的方向增长。 heap段：包含运行时分配的内存块，通常通过调用C标准库函数malloc来分配。通常在static段的上面，在扩张过程中，它向高地址的方向增长。  静态局部变量  栈上的局部变量有时称为\u0026quot;自动变量\u0026rdquo;，它们当函数创建时自动被分配，并且当函数返回时自动被释放。\nC中有另一种局部变量，叫做\u0026quot;静态变量\u0026rdquo;，它分配在static段上。它在程序启动时初始化，并且在函数调用之间保存它的值。\n地址翻译  虚拟地址(VA)翻译成物理地址(GA)\n大多数处理器提供了内存管理单元(MMU)，位于CPU和主存之间。MMU在VA和PA之间执行快速的翻译。\n 当程序读写变量时，CPU会得到VA。 MMU将VA分成两部分，称为页码和偏移。\u0026ldquo;页\u0026quot;是一个内存块，页的大小取决于操作系统和硬件，通常为1~4KiB MMU在\u0026quot;页表\u0026quot;里查找页码，然后获取相应的物理页码。之后将物理页码和偏移组合得到PA。 PA传递给主存，用于读写指定地址。   文件和文件系统 #  “文件系统”将每个文件的名称映射到它的内容。是一种键值对的数据库。 “文件”是一组字节序列。\n文件名通常是字符串，并且通常是分层的。这个字符串指定了顶级目录的路径，通过一系列子目录，到达特定的文件。\n文件是基于字节的，而持久化存储器是基于块的。操作系统将C标准库中基于字节的文件操作翻译成基于块的存储设备操作。\n 文件的读取和写入过程：    读取\n 程序使用文件名寻找顶级目录，子目录以及n级目录 找到名为xxx的文件，并且\u0026quot;打开\u0026quot;它以便读取。实际上是创建了一个数据结构料表示将要读取的文件。数据结构还跟踪了文件读取了多少字节，称为“文件位置”。 操作系统检查下个字节是否已经在内存中。如果是的话，读取下一个字节，向前移动文件位置，并返回结果。 如果不在内存中，操作系统产生IO请求来获取下一个块。 IO操作完成时，新的数据快回存储在内存中。 当进程关闭文件时，操作系统完成或取消任何等待中的操作，移除内存中的数据，并且释放OpenFileTableEntry    写入\n 程序使用文件名寻找文件。如果文件不存在，就会创建新的文件，并向父目录添加条目 操作系统创建OpenFileTableEntry，表示这个文件已打开等待写入，并将文件位置设置为0. 程序尝试写入文件的第一个字节。如果文件存在，操作系统需要将第一个块加载到内存中。否则它会在内存中分配新的块，并且在磁盘上请求新的块。 在内存中的块被修改后，可能不会立即复制回磁盘。通常，写到文件中的数据是“被缓冲的”，意思是它存储在内存中，只在至少有一个块需要写入时才写回磁盘。 文件关闭时，任何缓冲的数据都会写到磁盘，并且OpenFileTableEntry会被释放。    C标准库提供了文件系统的抽象，将文件名称映射到字节流。这个抽象建立在实际以块组织的存储设备之上。\n磁盘性能  操作系统和硬件提供了一些特性用于弥补主存和持久化存储器的性能间隔。\n 块的传输 预取 缓冲  磁盘元数据  块可以放在磁盘上的任意位置，使用各种数据结构来跟踪这些块。\n在UNIX文件系统中，这些数据结构叫做inode，它代表“索引节点”(index node)。也叫做“元数据”(数据的数据)\n块的分配  操作系统既要跟踪哪些块属于哪个文件，也需要跟踪哪些块可供使用。\n块分配系统的目标：\n 速度：块的分配和释放应该很快。 最小的空间开销 最少的碎片 最大的连续性   内存管理 #  动态内存分配函数：\n malloc， 接受表示字节单位的大小的整数，返回指向新分配的、(至少)为指定大小的内存块的指针。如果不满足，返回NULL指针 calloc， 和malloc一样，还会清空新分配的空间。 free， 它接受指向之前分配的内存块的指针，并会释放它 realloc，接受指向之前分配的内存块的指针，和一个新的大小    内存错误\n 访问任何没有分配的内存块 释放某个内存块之后再访问它 释放一个没有分配的内存块 释放多次相同的内存块 使用没有分配或者已经释放的内存块调用realloc    内存泄漏\n分配了一块内存，并且没有释放它，导致内存总量无限增长\n  实现\n   缓存 #   程序如何运行  操作系统创建新的进程来运行程序，之后\u0026quot;加载器\u0026quot;将代码从存储器复制到主存中，并且通过调用main来启动程序。\n在程序运行时，大部分数据存储在主存中，一些数据存储在寄存器中，它是CPU上的小型存储单元，包括：\n 程序计数器(PC)，含有程序下一条指令(在内存中)的地址 指令寄存器(IR)，含有当前执行的指令的机器码。 栈指针(SP)，含有当前函数栈帧的指针，其中包含函数参数和局部变量。 程序当前使用的存放数据的通用寄存器。 状态寄存器，含有当前计算的信息。  在程序运行时，CPU执行下列步骤，叫做\u0026quot;指令周期\u0026rdquo;：\n 取指(Fetch)：从内存中获取下一条指令，存储在指令寄存器中。 译码(Decode)：控制单元将指令译码，并向CPU的其他部分发送信号。 执行(Execute)：收到来自控制单元的信号后会执行合适的计算。  缓存性能  \u0026ldquo;缓存\u0026quot;是CPU上小型、快速的存储空间。\n当CPU从内存中读取数据时，它将一份副本存到缓存中。如果再次读取相同的数据，CPU就直接读取缓存。\n存储器层次结构     设备 访问时间 通常大小     寄存器 0.5 ns 256 B   缓存 1 ns 2 MiB   DRAM 10 ns 4 GiB   SSD 10 us 100 GiB   HDD 5 ms 500 GiB     缓存策略\n  页面调度\n  操作系统可以将页面在存储器和内存之间移动。这种机制叫做\u0026quot;页面调度\u0026rdquo;。\n工作流程:\n 进程A调用malloc来分配页面。如果堆中没有所请求大小的空闲空间，malloc会调用sbrk向操作系统请求更多内存。 如果物理内存中有空闲页，操作系统会将其加载到进程A的页表，创建新的虚拟内存范围。 如果没有空闲页面，调度系统会选择一个属于进程B的\u0026quot;牺牲页面\u0026rdquo;。它将页面内容从内存复制到磁盘，之后修改进程B的页表来表示这个页面\u0026quot;被换出\u0026rdquo; 一旦进程B的数据被写入，页面会重新分配给进程A。为了防止进程A读取进程B的数据，页面应被清空。 此时sbrk的调用可以返回，向malloc提供堆区额外的空间。之后malloc分配所请求的内存并返回。进程A可以继续执行。 当进程A执行完毕，或中断后，调度器可能会让进程B继续执行。当它访问到被换出的页面时，内存管理器单元注意到这个页面是\u0026quot;无效\u0026quot;的，并且会触发中断。 当操作系统处理中断时，它会看到页面被换出了，于是它将页面从磁盘传送到内存。 一旦页面被换入之后，进程B可以继续执行。  页面调度可以极大提升物理内存的利用水平，允许更多进程在更少的空间内执行。原因：\n 大多数进程不会用完所分配内存。这些页面被换出而不会引发任何问题。 如果程序泄漏了内存，它可能会丢掉所分配的空间。通过将这些页面换出，可以有效填补泄漏。 当进程闲置时，这些进程可以被换出 当多进程运行同一个程序时，进程可以共享相同的text段，避免在物理内存中保留过多副本。   多任务 #  CPU包含多个核心，也就是说可以运行多个进程。并且，每个核心都具有\u0026quot;多任务\u0026quot;的能力。也就是说它可以从一个进程快速切换到另一个进程，创造出同时运行许多进程的幻象。\n在操作系统中，多任务由内核实现。其本质就是处理中断。“中断”是一个事件，它会停止通常的指令周期，并且使执行流跳到称为“中断处理器”的特殊代码区域内。\n当一个设备向CPU发送信号时，会发生硬件中断。软件中断由运行中的程序所产生。\n当程序需要访问硬件设备时，会进行“系统调用”，它就像函数调用，除了并非跳到函数的起始位置，而是执行一条特殊的指令来触发中断，使执行流跳到内核中。内核读取系统调用的参数，执行所请求的操作，之后使被中断进程恢复运行。\n 硬件状态   当中断发生时，硬件将程序计数器保存到一个特殊的寄存器中，并且跳到合适的中断处理器。 中断处理器将程序计数器和位寄存器，以及任何打算使用的数据寄存器的内容储存到内存中。 中断处理器运行处理中断所需的代码。 之后它复原所保存寄存器的内容。最后，复原被中断进程的程序计数器，这会跳回到被中断的进程。  上下文切换  中断处理器非常快，因为它们不需要保存整个硬件状态。它们只需要保存打算使用的寄存器。\n但是当中断发生时，内核并不总会恢复被中断的进程。它可以选择切换到其它进程，这种机制叫做“上下文切换”。\n进程的生命周期  当进程被创建时，操作系统会为进程分配包含进程信息的数据结构，称为“进程控制块”（PCB）。在其它方面，PCB跟踪进程的状态，这包括：\n 运行（Running），如果进程正在运行于某个核心上。 就绪（Ready），如果进程可以但没有运行，通常由于就绪进程数量大于内核的数量。 阻塞（Blocked），如果进程由于正在等待未来的事件，例如网络通信或磁盘读取，而不能运行。 终止（Done）：如果进程运行完毕，但是带有没有读取的退出状态信息。  下面是一些可导致进程状态转换的事件：\n 一个进程在运行中的程序执行类似于fork的系统调用时诞生。在系统调用的末尾，新的进程通常就绪。之后调度器可能恢复原有的进程（“父进程”），或者启动新的进程（“子进程”）。 当一个进程由调度器启动或恢复时，它的状态从就绪变为运行。 当一个进程被中断，并且调度器没有选择使它恢复，它的状态从运行变成就绪。 如果一个进程执行不能立即完成的系统调用，例如磁盘请求，它会变为阻塞，并且调度器会选择另一个进程。 当类似于磁盘请求的操作完成时，会产生中断。中断处理器弄清楚哪个进程正在等待请求，并将它的状态从阻塞变为就绪。 当一个进程调用exit时，中断处理器在PCB中储存退出代码，并将进程的状态变为终止。  调度  大多数情况下，只有一小部分进程是就绪或者运行的。当中断发生时，调度器会决定那个进程应启动或恢复。\n大多数调度器使用一些基于优先级的调度形式，其中每个进程都有可以调上或调下的优先级。当调度器运行时，它会选择最高优先级的就绪进程。\n下面是决定进程优先级的一些因素：\n 具有较高优先级的进程通常运行较快。 如果一个进程在时间片结束之前发出请求并被阻塞，就可能是IO密集型程序或交互型程序，优先级应该升高。 如果一个进程在整个时间片中都运行，就可能是长时间运行的计算密集型程序，优先级应该降低。 如果一个任务长时间被阻塞，之后变为就绪，它应该提升为最高优先级，便于响应所等待的东西。 如果进程A在等待进程B的过程中被阻塞，例如，如果它们由管道连接，进程B的优先级应升高。 系统调用nice允许进程降低（但不能升高）自己的优先级，并允许程序员向调度器传递显式的信息。  实时调度  调度满足截止期限的任务叫做“实时调度”。对于一些应用，类似于Linux的通用操作系统可以被修改来处理实时调度。这些修改可能包括：\n 为控制任务的优先级提供更丰富的API。 修改调度器来确保最高优先级的进程在固定时间内运行。 重新组织中断处理器来保证最大完成时间。 修改锁和其它同步机制（下一章会讲到），允许高优先级的任务预先占用低优先级的任务。 选择保证最大完成时间的动态内存分配实现。   "});index.add({'id':49,'href':'/notes/docs/technology/other/Interview/classic/','title':"Classic",'content':"经典问题 #  1. 当输入google.com时，发生了什么？ #  1.1 URL解析 #  当输入的URL不合法时，浏览器会将输入的字符传给默认搜索引擎，\n浏览器通过URL能知道以下信息：\nprotocol: http host: google.com resource: / 1.2 HTST #  1、浏览器检查自身的HTST列表，确认是否包含该主机。 2、若HTST存在该主机，使用https代替http，否则使用http。 1.3 DNS解析 #  1、浏览器检查自身的DNS缓存 2、查找本地hosts文件 3、发起DNS解析查询 4、查询 本地|ISP DNS服务器 5、本地|ISP DNS服务器像高层服务器发起递归查询直到查到该域名的解析IP 1.4 TCP连接建立 #  1、client端发送SYN请求到server端，声明自己的ISN为aaa (CLOSED--\u0026gt;SYN-SENT) 2、server端接收SYN包，声明自己的ISN为bbb，ACK信息为aaa+1，返回给client端 (LISTEN--\u0026gt;SYN-RECEIVED) 3、client端返回ACK为bbb+1为server端 (SYN-SENT--\u0026gt;ESTABLISHED) 4、数据交互 1.5 TLS连接建立 #  1.6 HTTP #   "});index.add({'id':50,'href':'/notes/docs/technology/other/Interview/hangzhou/','title':"Hangzhou",'content':"面试经历 #  club factory #   如何部署 如何监控 部署怎么实现 docker的优势和劣势  "});index.add({'id':51,'href':'/notes/docs/technology/other/Interview/interview/','title':"Interview",'content':"面试笔记 #  面试准备 #     技术知识点\n  非技术相关()\n  面试经历总结 #     经典问题\n   杭州面试\n  "});index.add({'id':52,'href':'/notes/docs/technology/other/Interview/technology/','title':"Technology",'content':"技术知识点 #  硬件 #  1. 机器型号 #  dmidecode | awk -F\u0026#39;:\u0026#39; \u0026#39;/Product Name/{print $2}\u0026#39; 2. CPU信息 #  #获取逻辑CPU数 awk -F':' '/name/{print $2}' /proc/cpuinfo | wc -l #获取CPU型号 awk -F':' '/name/{print $2}' /proc/cpuinfo | uniq #获取物理cpu数 grep \u0026quot;physical id\u0026quot; /proc/cpuinfo | sort | uniq | wc -l 3. 内存信息 #  #获取内存大小 free -h #内存物理信息 dmidecode -t memory 4. 磁盘信息 #   5. 计算机组成 #  1. 控制器 2. 运算器 3. 存储器 4. 输入设备 5. 输出设备 系统 #   网络 #  1. TCP协议 #  1.1三次握手 #  1、server端开启端口监听。(CLOSED--\u0026gt;LISTEN) 2、client端发送SYN信息给server端。(CLOSED--\u0026gt;SYN-SENT) 3、server端接收SYN信息，返回ACK信息和SYN信息给client端。(LISTEN--\u0026gt;SYN-RECEIVED) 4、client端接收ACK和SYN信息，并返回一个ACK信息给server端.(SYN-SENT--\u0026gt;ESTABLISHED) 5、server端接收ACK信息。(SYN-RECEIVED--\u0026gt;ESTABLISHED) 6、连接建立  1.2四次挥手 #  1、client端主动发起关闭请求，发送FIN信息给server端(ESTABLISHED--\u0026gt;FIN-WAIT-1) 2、server端接收FIN信息，并返回一个ACK信息，等待应用确认关闭连接(ESTABLISHED--\u0026gt;CLOSE-WAIT) 3、client端接收ACK信息，等待server端的FIN信息(FIN-WAIT-1--\u0026gt;FIN-WAIT-2) 4、server端确认关闭，发送FIN信息给client端(CLOSE-WAIT--\u0026gt;LAST-ACK) 5、client端接收FIN信息，返回一个ACK信息。(FIN-WAIT-2--\u0026gt;TIME-WAIT) 6、server端接收ACK信息，关闭连接。(LASK-ACK--\u0026gt;CLOSED) 7、client端超时关闭连接。(TIME-WAIT--\u0026gt;CLOSED) 8、连接关闭 2. DNS #  1、查找本机缓存 2、查找本地hosts 3、查找路由器缓存 4、查找本地/ISP DNS服务器 5、查找根服务器 6、递归查询直到查到域名解析IP 7、本地DNS服务器缓存，返回给本机 3. HTTP #   WEB #  1. CDN #  1. client请求www.cctest.com 2. www.cctest.com CNAME 到 cctest.cdncache.com 3. CDN内部根据源IP得到离源IP最近的Cache服务器IP，并返回给client 4. client向Cache服务器发起请求 5. 请求内容存在，直接返回给client 6. 请求内容不存在，Cache服务器向RealServer请求内容 7. Cache服务器缓存RealServer的内容，并将内容返回给client 2.Lvs #  四层负载均衡\n1. client向LVS发起请求 2. LVS根据路由模式和调度算法分配realserver 3. client向realserver发起请求 路由模式:\n  NAT\n1. client request load balance 2. load balance 选择一台 realserver 3. 更改packet的dest ip port 为realserver的ip port 4. realserver接收并返回请求 5. load balance 更改packet的source ip port 为 loadbalance的ip port   DR\n1. client request load balance 2. load balance 选择一台 realserver 3. 更改目的mac地址，转发到realserver 4. realserver接受请求，返回给client   TUN\n1. client request load balance 2. load balance 选择一台 realserver 3. 通过tunnel将请求转发给realserver 4. realserver接受请求，返回给client   调度算法：\n1. rr 2. wrr 3. lc 4. wlc 5. lblc 6. lblcr 7. dh 8. sh 9. sed 10. nq 3.Nginx #  WEB服务器，七层负载，反向代理\n4.Tomcat #   大数据 #   编程 #  "});index.add({'id':53,'href':'/notes/docs/technology/other/MyConfig/config/','title':"Config",'content':"打造自己开发环境 #  vim #     配置指南\n   基础配置\n   插件配置\n   开发配置\n   tmux #    基础配置   xshell #    颜色配置  "});index.add({'id':54,'href':'/notes/docs/technology/other/MyConfig/vim/vimconf/','title':"Vimconf",'content':"Vim配置指南 #  Don\u0026rsquo;t put any lines in your vimrc that you don\u0026rsquo;t understand. #      Colors\n   Spaces And Tabs\n   UI Config\n   Searching\n   Folding\n   Custom Movements\n   Custom Leader\n   CtrlP Settings\n   Launch Config\n   Tmux Config\n   Autogroups\n   Backups\n   Custom Functions\n   Organization\n   Wrapping It Up\n   Colors colorscheme badwolf \u0026quot; 设置色彩方案 systax enable \u0026quot; 开启语法处理   Spaces \u0026 Tabs set tabstop=4 \u0026quot; 设置每个TAB的视觉空格数 set softtabstop=4 \u0026quot; 设置编辑时tab的空格数 set expandtab \u0026quot; 将\u0026lt;TAB\u0026gt;符号转换为空格   UI Config set number \u0026quot; 显示行号 set showcmd \u0026quot; 在vim右下方显示最后一个命令，在powerline插件内有效 set cursorline \u0026quot; 当前行高亮 "});index.add({'id':55,'href':'/notes/docs/technology/other/Solution/aboutNtpdate/','title':"About Ntpdate",'content':"时间同步相关问题 #  ntpdate:no server suitable for synchronization found #  Question： #  　在使用ntpdate同步时间时，出现了no server suitable for synchronization found的报错。\n　通过ntpdate -d s2m.time.edu.cn 使用debug模式没有出现异常。\nAnswer： #  解决办法是，使用ntpdate -ubv s2m.time.edu.cn，可以正常同步了。\n主要是-u选项的作用\n-u：Direct ntpdate to use an unprivileged port for outgoing packets. This is most useful when behind a firewall that blocks incoming traffic to privileged ports, and you want to synchronize with hosts beyond the firewall. Note that the -d option always uses unprivileged ports.   "});index.add({'id':56,'href':'/notes/docs/technology/other/Solution/aboutSsh/','title':"About Ssh",'content':"ssh连接相关问题 #  pam_tally2(sshd:auth): user root (0) has time limit [3s left] since last failure 日志 #  Question： #  工作中，碰到某服务器在批量ssh登陆操作时，出现大量的无法连接的情况。\nThinking： #  查看ssh日志(/var/log/secure)， 首先注意到的是，\u0026ldquo;Failed password for root from xxx.xxx.xxx.xxx port 51230 ssh2\u0026quot;错误，但发现密码并没有错误，并且只在批量操作时才会出现，故初步判断为连接数问题。\n查看ssh连接数限制\n/usr/sbin/sshd -T | grep -i max  调整参数，更改配置文件/etc/sshd/sshd_config\nmaxsessions 1000  重启服务后，依然没有效果。\n再次查看日志，发现在做批量操作时，有大量的\u0026quot;pam_tally2(sshd:auth): user root (0) has time limit [3s left] since last failure\u0026quot;日志。\n应该是pam模块做了相应的限制\n查看配置文件 /etc/pam.d/sshd 文件\nauth required pam_tally2.so deny=10 lock_time=3 unlock_time=30 even_deny_root root_unlock_time=30  Answer： #  更改配置文件：\n#auth required pam_tally2.so deny=10 lock_time=3 unlock_time=30 even_deny_root root_unlock_time=30   "});index.add({'id':57,'href':'/notes/docs/technology/other/Solution/README/','title':"R E a D M E",'content':"问题解决方案 #     时间同步相关\n   ssh连接相关\n   PGSQL相关\n  "});index.add({'id':58,'href':'/notes/docs/technology/other/Translate/translate/','title':"Translate",'content':"翻译技术文章 #  "});index.add({'id':59,'href':'/notes/docs/technology/program/Advanced/Algorithm/algorithm/','title':"Algorithm",'content':"算法 #   冒泡排序  对于一个无序的序列，每次对比两个相邻数的大小，若第i个数大于第i+1个数，两个数进行位置互换。每组排序可以选出一个最大的数，然后继续从第一个数开始进行对比，直到完成排序\n#伪代码 int num[] for(int i=0; i \u0026lt; num.length-1; i++){ for(int j=0; j \u0026lt; num.length-i-1; j++){ if( num[j] \u0026gt; num[j+1] ){ int temp = num[j] num[j+1] = num[j] num[j] = temp } } }   选择排序  对于一个无序的序列，从第一个数开始，每次跟接下去的数对比，若第1个数小于第i个数，两个数位置互换，每次选出最小的数，然后开始对比第二个数，直到完成排序。\n#伪代码 int num[] for(int i=0; i \u0026lt; num.length-1; i++){ for(int j=i+1; j \u0026lt; num.length-1; j++){ if( num[i] \u0026gt; num[j] ){ int temp = num[i] num[i] = num[j] num[j] = temp } } }   归并排序  对于一个无序的序列，将序列用递归的方式划分成左右两个序列，然后依次排序合并序列。\n#伪代码 func sorted(int num[]){ if(num.length\u0026lt;=1){ return num[0] } leftnum = xxx rightnum = xxx sorted(leftnum[]) sorted(rightnum[]) merge(leftnum,rightnum) }  "});index.add({'id':60,'href':'/notes/docs/technology/program/Advanced/DataStructure/datastructure/','title':"Datastructure",'content':"数据结构 #    链表\n  堆栈\n  队列\n  哈希表\n  二叉排序树\n  单词查找树\n  "});index.add({'id':61,'href':'/notes/docs/technology/program/Advanced/Design/factoryMethod/','title':"Factory Method",'content':"工厂方法模式(Factory Method Pattern) #  模式定义 #  工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n 模式结构 #    Product：抽象产品\n  ConcreteProduct：具体产品\n  Factory：抽象工厂\n  ConcreteFactory：具体工厂\n   "});index.add({'id':62,'href':'/notes/docs/technology/program/Advanced/Design/README/','title':"R E a D M E",'content':"设计模式 #  设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。\n 分类 #  创建型模式 #  创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。\n   简单工厂模式\n   工厂方法模式\n   抽象工厂模式\n   建造者模式\n   原型模式\n   单例模式\n   结构型模式 #   行为型模式 #  "});index.add({'id':63,'href':'/notes/docs/technology/program/Advanced/Design/simpleFactory/','title':"Simple Factory",'content':"简单工厂模式(Simple Factory Pattern) #  模式定义 #  简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n 模式结构 #    Factory：工厂角色\n工厂角色负责实现创建所有实例的内部逻辑\n  Product：抽象产品角色\n抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n  ConcreteProduct：具体产品角色\n具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n   "});index.add({'id':64,'href':'/notes/docs/technology/program/Basic/README/','title':"R E a D M E",'content':"编程基础 #  编程语言 #    解释型语言\n 程序由解释器读取并执行 SoucreCode --\u0026gt; Interpreter --\u0026gt; Output    编译型语言\n 程序被编译器翻译成机器语言后再执行 SourceCode --\u0026gt; Compliler --\u0026gt; ObjectCode --\u0026gt; Executor --\u0026gt; Output     什么是程序？ #  程序是指定如何执行计算的指令序列。\n不同的编程语言具有一些共同的基础特性：\n input：从键盘，文件或者其他输入设备中获取数据。 output：在屏幕显示数据，或者将数据发送给文件或者输出设备。 math：执行基本的数学运算，比如加法和乘法。 conditional execution：检查条件并执行相应的代码。 repetition：反复执行一些操作。  编程可以视为将大型的复杂任务打破成更小和更小的子任务，直到子任务简单到足以执行上述的基本操作的过程。\n 调试(debugging) #  编程容易出错。编程错误被称为错误，并且跟踪它们的过程称为调试。\n Syntax errors：语法错误(语法是指程序的结构和关于该结构的规则)。 Runtime errors(exceptions)：运行时错误(异常)。 Semantic errors：语义错误，做的不是你想要让它做的事情。  调试是通过更改程序去发现和解决错误。\n 数据类型(type) #   interger：整数，例如1,2 string: 字符串，例如\u0026rsquo;Hello\u0026rsquo;   变量(variables) #  变量是引用值的名称，编程语言最强大的功能之一就是操纵变量的能力。\n variable：变量名，由字母开头并由字母或数字组成。最好由小写字母开头。 keyword：关键字，用于识别程序的结构，它们不能用作变量名称。例如,if,for,while   运算符(operators)和操作数(operands) #   operators：运算符，表示计算的特殊符号，例如+,-,* operands：操作数   表达式(expressions)和语句(statements) #   expression：表达式，是值、变量和运算符的组合。 statement：语句是可执行的代码单元。   注释(comments) #  在程序中添加笔记，用于解释程序正在做什么\n 流程控制(control flow) #  在程序运行时，控制个别的指令运行的顺序。\n控制结构：控制结构开始时多半都会有特定的关键字，以标明使用哪一种控制结构\n choice：选择结构  if-then-else： switch case   loop：循环结构  for while     函数(functions) #  函数是组织好的，可重复使用的，用于实现单一或相关联功能的代码段。\n function call：函数调用，一些语言一般由很多内置的函数可供调用。例如，type(32) function definition：定义函数，例如，def hello(): print(\u0026lsquo;Hello,World!') flow of execution：执行流程，程序总是从第一行开始按序执行语句，函数内部的语句并不会被执行，直到函数被调用。 parameter：参数，函数中用于供外部传入值的变量名。 why function?：  便于程序阅读 消除重复代码 便于调式功能 便于重用     模块(Modules) #   接口(interface) #   类(classes)和对象(objects) #   "});index.add({'id':65,'href':'/notes/docs/technology/program/Python/CookBook/DataStructuresAndAlgorithms/README/','title':"R E a D M E",'content':"数据结构和算法 #    解压序列赋值给多个变量\n问题，现在有一个包含N个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给N个变量？\n实现： 详细代码\n \u0026gt;\u0026gt;\u0026gt; data = ['John',170,60,(1999,9,9)] \u0026gt;\u0026gt;\u0026gt; name, height, weight, birthday = data ### 另一种方式 \u0026gt;\u0026gt;\u0026gt; name, height, weight, (year, mon, day) = data    解压可迭代对象赋值给多个变量\n问题，如果一个可迭代对象的元素个数超过变量个数时，会抛出一个ValueError。那么怎样才能从这个可迭代对象中解压出N个元素出来？\n实现： 详细代码\n \u0026gt;\u0026gt;\u0026gt; record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212') \u0026gt;\u0026gt;\u0026gt; name, email, *phone_numbers = record    保留最后N个元素\n问题，在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？\n实现： 详细代码\n \u0026gt;\u0026gt;\u0026gt; from collections import deque \u0026gt;\u0026gt;\u0026gt; q = deque(maxlen = 3) \u0026gt;\u0026gt;\u0026gt; q.append(1) \u0026gt;\u0026gt;\u0026gt; q.append(2) \u0026gt;\u0026gt;\u0026gt; q.append(3) \u0026gt;\u0026gt;\u0026gt; q deque([1, 2, 3], maxlen=3) \u0026gt;\u0026gt;\u0026gt; q.append(4) \u0026gt;\u0026gt;\u0026gt; q deque([2, 3, 4], maxlen=3)    查找最大或最小的N个元素\n问题，怎样从一个集合中获得最大或者最小的N个元素列表？\n实现： 详细代码\n \u0026gt;\u0026gt;\u0026gt; import heapq \u0026gt;\u0026gt;\u0026gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] \u0026gt;\u0026gt;\u0026gt; heapq.nlargest(3,nums) [42, 37, 23] \u0026gt;\u0026gt;\u0026gt; heapq.nsmallest(3,nums) [-4, 1, 2]    实现优先级队列\n问题，给定一个具有优先级的队列，每次pop操作取出优先级最高的Item\n实现： 详细代码\n \u0026gt;\u0026gt;\u0026gt; from heapq import heappush, heappop \u0026gt;\u0026gt;\u0026gt; heap = [] \u0026gt;\u0026gt;\u0026gt; data = [(2,'A'),(7,'B'),(5,'C')] \u0026gt;\u0026gt;\u0026gt; for item in data: ... heappush(heap, item) ... \u0026gt;\u0026gt;\u0026gt; print(heappop(heap)[-1]) A \u0026gt;\u0026gt;\u0026gt; print(heappop(heap)[-1]) C \u0026gt;\u0026gt;\u0026gt; print(heappop(heap)[-1]) B    字典中将键映射到多个值\n问题，字典是每个键映射到单个值的映射。如果要将键映射到多个值，则需要将多个值存储在另一个容器中，例如列表或集合。\n实现： 详细代码\n \u0026gt;\u0026gt;\u0026gt; d = {'a':[1,2,3],'b':[4,5]} \u0026gt;\u0026gt;\u0026gt; d = {'a':{1,2,3},'b':{4.5}} #另一种实现 \u0026gt;\u0026gt;\u0026gt; from collections import defaultdict \u0026gt;\u0026gt;\u0026gt; d = defaultdict(list) \u0026gt;\u0026gt;\u0026gt; d['a'].append(1) \u0026gt;\u0026gt;\u0026gt; d['a'].append(2) \u0026gt;\u0026gt;\u0026gt; d['b'].append(4)    有序字典\n问题，想使用字典，并且想在迭代的时候控制输出顺序。\n实现,： 详细代码\n \u0026gt;\u0026gt;\u0026gt; from collections import OrderedDict \u0026gt;\u0026gt;\u0026gt; d = OrderedDict()    用字典计算\n问题，想用字典内的数据做各种计算(最大值，最小值，排序等)\n实现： 详细代码\n \u0026gt;\u0026gt;\u0026gt; prices = {'APPLE':23.33,'ORANGE':33.55,'BANANA':11.23} \u0026gt;\u0026gt;\u0026gt; print(min(zip(prices.values(),prices.keys()))) (11.23, 'BANANA') \u0026gt;\u0026gt;\u0026gt; print(max(zip(prices.values(),prices.keys()))) (33.55, 'ORANGE') \u0026gt;\u0026gt;\u0026gt; print(sorted(zip(prices.values(),prices.keys()))) [(11.23, 'BANANA'), (23.33, 'APPLE'), (33.55, 'ORANGE')]    查找两个字典的共性\n问题，比对两个字典，返回两个字典的共性。\n实现， 详细代码\n \u0026gt;\u0026gt;\u0026gt; a = {'x':1,'y':2,'z':3} \u0026gt;\u0026gt;\u0026gt; b = {'w':10,'x':11,'y':2} \u0026gt;\u0026gt;\u0026gt; a.keys() \u0026amp; b.keys() {'x', 'y'} \u0026gt;\u0026gt;\u0026gt; a.keys() - b.keys() {'z'} \u0026gt;\u0026gt;\u0026gt; a.items() \u0026amp; b.items() {('y', 2)}    删除列表的重复项\n问题，排除列表中的重复项，并保留顺序。\n实现， 详细代码\n\u0026gt;\u0026gt;\u0026gt; seen = set() \u0026gt;\u0026gt;\u0026gt; for item in [1,3,5,9,1]: ... if item not in seen: ... seen.add(item) \u0026gt;\u0026gt;\u0026gt; list(seen) [1, 3, 5, 9]    命名一个分片\n问题，清除混乱的内容\n实现， 详细代码\n\u0026gt;\u0026gt;\u0026gt; record = '....................100 .......513.25 ..........' \u0026gt;\u0026gt;\u0026gt; SHARES = slice(20,32) \u0026gt;\u0026gt;\u0026gt; PRICE = slice(40,48) \u0026gt;\u0026gt;\u0026gt; cost = int(record[SHARES]) * float(record[PRICE]) \u0026gt;\u0026gt;\u0026gt; print(cost) 51325.0    查找队列中最常出现的item\n问题，有一个队列，想找出出现最频繁的item\n实现， 详细代码\n\u0026gt;\u0026gt;\u0026gt; from collections import Counter \u0026gt;\u0026gt;\u0026gt; words = ['look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes','look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',] \u0026gt;\u0026gt;\u0026gt; word_counts = Counter(words) \u0026gt;\u0026gt;\u0026gt; top_two = word_counts.most_common(2) \u0026gt;\u0026gt;\u0026gt; print(top_two) [('look', 4), ('into', 4)]    根据公共的key排序字典列表\n问题，你有一个字典的列表，你想根据一个或多个字典值排序条目。\n实现， 详细代码\n\u0026gt;\u0026gt;\u0026gt; rows = [ {'fname':'Brain','uid':1003}, ... {'fname':'Jhon','uid':1002}, ... {'fname':'Alin','uid':1005}] \u0026gt;\u0026gt;\u0026gt; from operator import itemgetter \u0026gt;\u0026gt;\u0026gt; rows_by_uid = sorted(rows,key=itemgetter('uid')) \u0026gt;\u0026gt;\u0026gt; print(rows_by_uid) [{'fname': 'Jhon', 'uid': 1002}, {'fname': 'Brain', 'uid': 1003}, {'fname': 'Alin', 'uid': 1005}]    排序不支持比较的对象\n问题，你想对同一类对象进行排序，但它本身并不支持比较\n实现， 详细代码\n  基于特定字段的值进行分组\n问题，有一系列字典或实例，希望根据特定字段的值来迭代数据，例如日期。\n实现， 详细代码\n  过滤队列中的元素\n问题，你有一个队列需要通过某些标准提取或者减少值\n实现， 详细代码\n\u0026gt;\u0026gt;\u0026gt; mylist = [1, 4, 3, -2, 5, 0] \u0026gt;\u0026gt;\u0026gt; [n for n in mylist if n \u0026gt; 0] [1, 4, 3, 5]    提取字典的子集\n问题，制作一个字典是另一个字典的一个子集\n实现， 详细代码\n  名称映射到序列中的元素\n问题，通过按名称访问元素，减少对结构中的位置的依赖\n实现， 详细代码\n\u0026gt;\u0026gt;\u0026gt; from collections import namedtuple \u0026gt;\u0026gt;\u0026gt; Subscriber = namedtuple('Subscriber', ['addr', 'joined']) \u0026gt;\u0026gt;\u0026gt; sub = Subscriber('test@examole.com', '2017-07-31') \u0026gt;\u0026gt;\u0026gt; sub Subscriber(addr='test@examole.com', joined='2017-07-31') \u0026gt;\u0026gt;\u0026gt; sub.addr 'test@examole.com' \u0026gt;\u0026gt;\u0026gt; sub.joined '2017-07-31'    同时转换和减少数据\n问题，您需要执行缩减功能(例如sum(),min(),max()),但首先需要转换或过滤数据.\n实现， 详细代码 \u0026raquo;\u0026gt; nums = [1,2,3,4,5] \u0026raquo;\u0026gt; s = sum(x*x for x in nums) \u0026raquo;\u0026gt; print(s) 55\n  将多个映射组合成单个映射\n问题，您有多个字典或映射，您要逻辑组合成一个映射来执行某些操作，例如查找值或检查键的存在\n实现， 详细代码\n\u0026gt;\u0026gt;\u0026gt; a = {'x': 1, 'z': 3 } \u0026gt;\u0026gt;\u0026gt; b = {'y': 2, 'z': 4 } \u0026gt;\u0026gt;\u0026gt; from collections import ChainMap \u0026gt;\u0026gt;\u0026gt; c = ChainMap(a,b) \u0026gt;\u0026gt;\u0026gt; c ChainMap({'x': 1, 'z': 3}, {'y': 2, 'z': 4})   "});index.add({'id':66,'href':'/notes/docs/technology/program/Python/CookBook/StringsAndText/README/','title':"R E a D M E",'content':"#字符串和文本\n   "});index.add({'id':67,'href':'/notes/docs/technology/program/Python/Framework/Django/django/','title':"Django",'content':"Django #  环境初始化 #  python3 install virtualenv cd demosite mkdir py3env virtualenv ./py3env/ source py3env/bin/activate #install Django pip3 install Django  项目初始化 #  django-admin startproject demosite python manage.py runserver python manage.py startapp polls  项目结构 #  demosite/ manage.py demosite/ __init__.py settings.py urls.py wsgi.py polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py  "});index.add({'id':68,'href':'/notes/docs/technology/program/Python/Framework/Flask/flask/','title':"Flask",'content':"Flask #  安装 #  pip install flask   程序基本结构 #   初始化  所有 Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为 Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。\nfrom flask import Flask app = Flask('__name__')  路由和函数  程序实例需要知道对每个URL请求运行哪些代码，所以保存了一个URL到Python函数的映射关系。处理URL和函数之间关系的程序称为路由。 在Flask程序中定义路由的最简便方式，是使用程序实例提供的app.route修饰器，把修饰的函数注册为路由。\n@app.route('/') def index(): return '\u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt;'   启动服务\nif name == \u0026lsquo;main\u0026rsquo; app.run(Debug=True)\n   模版 #  模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。为了渲染模板，Flask 使用了一个名为 Jinja2 的强大模板引擎。\nJinja2模板引擎 #  templates/user.html：Jinja2 模板\n\u0026lt;h1\u0026gt;Hello {{ name }} !\u0026lt;/h1\u0026gt;   渲染模版  示例，使用render_template\n@app.route('/user/\u0026lt;name\u0026gt;') def user(name) return render_template('user.html',name=name)  变量  Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。\n\u0026lt;p\u0026gt;A value from a dictionary: {{ mydict['key'] }}.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;A value from a list: {{ mylist[3] }}.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;A value from a list, with a variable index: {{ mylist[myintvar] }}.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;A value from an object's method: {{ myobj.somemethod() }}.\u0026lt;/p\u0026gt;  可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。\nHello, {{ name|capitalize }}  过滤器\nsafe 渲染值时不转义 capitalize 把值的首字母转换成大写，其他字母转换成小写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大写 trim 把值的首尾空格去掉 striptags 渲染之前把值中所有的 HTML 标签都删掉  控制结构  Jinja2 提供了多种控制结构，可用来改变模板的渲染流程。\n{% 控制条件 %}   使用Flask-Bootstrap集成Twitter Bootstrap #  Bootstrap是Twitter开发的一个开源框架，它提供的用户界面组件可用于创建整洁且具有吸引力的网页，而且这些网页还能兼容所有现代 Web 浏览器。\npip install flask-bootstrap   初始化  示例\nfrom flask.ext.bootstrap import Bootstrap bootstrap = Bootstrap(app)   自定义错误页面 #  @app.errorhandler(404) def page_not_found(e): return render_template('404.html'), 404 @app.errorhandler(500) def internal_server_error(e): return render_template('500.html'), 500   链接 #  Flask 提供了 url_for() 辅助函数，它可以使用程序 URL 映射中保存的信息生成 URL。\n静态文件 #   使用Flask-Moment本地化日期和时间 #  示例\npip install flask-moment from flask.ext.moment import Moment moment = Moment(app) {% block scripts %} {{ super() }} {{ moment.include_moment() }} {% endblock %} \u0026lt;p\u0026gt;The local date and time is {{ moment(current_time).format('LLL') }}.\u0026lt;/p\u0026gt;   WEB表单 #  示例\npip install flask-wtf from flask.ext.wtf import Form from wtforms import StringField, SubmitField from wtforms.validators import Required class NameForm(Form): name = StringField('What is your name?', validators=[Required()]) submit = SubmitField('Submit')  表单渲染\n{% import \u0026quot;bootstrap/wtf.html\u0026quot; as wtf %} {{ wtf.quick_form(form) }}  视图处理表单：\nform = NameForm() return render_template('index.html', form=form)   数据库 #  初始化\npip install flask-sqlalchemy from flask.ext.sqlalchemy import SQLAlchemy basedir = os.path.abspath(os.path.dirname(__file__)) app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] =\\ 'sqlite:///' + os.path.join(basedir, 'data.sqlite') app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True db = SQLAlchemy(app)  模型定义\nclass Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) def __repr__(self): return '\u0026lt;Role %r\u0026gt;' % self.name  创建表\ndb.create_all()  插入行\nfrom hello import Role admin_role = Role(name='Admin') db.session.add(admin_role) db.session.commit()   电子邮件 #  pip install flask-mail   项目结构 #  多文件 Flask 程序的基本结构\nflasky\n app/  templates/ static/ main/  init.py errors.py forms.py views.py   init.py email.py models.py   migrations/ tests/  init.py test*.py   venv/ requirements.txt config.py manage.py  这种结构有 4 个顶级文件夹：\n Flask 程序一般都保存在名为 app 的包中； 和之前一样，migrations 文件夹包含数据库迁移脚本； 单元测试编写在 tests 包中； 和之前一样，venv 文件夹包含 Python 虚拟环境。 同时还创建了一些新文件： requirements.txt 列出了所有依赖包，便于在其他电脑中重新生成相同的虚拟环境； config.py 存储配置； manage.py 用于启动程序以及其他的程序任务。  "});index.add({'id':69,'href':'/notes/docs/technology/program/Python/Framework/Scrapy/scrapy/','title':"Scrapy",'content':"#Scrapy Scrapy是一个快速的高级Web爬网和Web抓取框架，用于抓取网站并从其页面提取结构化数据。\n安装 #  pip install scrapy scrapy startproject scrapytest   第一个爬虫 #  "});index.add({'id':70,'href':'/notes/docs/technology/program/Python/README/','title':"R E a D M E",'content':"Python #  基础语法 #    数据类型\n  流控\n  函数\n  模块\n   常用库 #   CookBook #     数据和算法\n   字符串和文本\n   框架 #     Flask\n   Scrapy\n   Django\n  "});index.add({'id':71,'href':'/notes/docs/technology/program/RevisionControl/git/','title':"Git",'content':"Git #  Git起步 #     Git简介\n   Git安装\n   Git配置\n   Git基础 #     创建版本库\n   记录更新\n   提交历史\n   撤销操作\n   远程仓库\n   标签\n   别名\n   Git分支 #   "});index.add({'id':72,'href':'/notes/docs/technology/program/RevisionControl/Git/alias/','title':"Alias",'content':"别名 #  在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。\nGit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n$ git config --global alias.co checkout $ git config --global alias.br branch $ git config --global alias.ci commit $ git config --global alias.st status  这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\n$ git config --global alias.unstage 'reset HEAD --'  这会使下面的两个命令等价：\n$ git unstage fileA $ git reset HEAD -- fileA  这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n$ git config --global alias.last 'log -1 HEAD'  这样，可以轻松地看到最后一次提交：\n$ git last commit 66938dae3329c7aebe598c2246a8e6af90d04646 Author: Josh Goebel \u0026lt;dreamer3@example.com\u0026gt; Date: Tue Aug 26 19:48:51 2008 +0800 test for current head Signed-off-by: Scott Chacon \u0026lt;schacon@example.com\u0026gt;  可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n$ git config --global alias.visual '!gitk' "});index.add({'id':73,'href':'/notes/docs/technology/program/RevisionControl/Git/commitHistory/','title':"Commit History",'content':"提交历史 #  查看提交历史 #  git log 命令，查看提交历史。\n$ git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit  默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。\n git log 常用选项 #  -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：\n$ git log -p -2 commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number diff --git a/Rakefile b/Rakefile index a874b73..8f94139 100644 --- a/Rakefile +++ b/Rakefile @@ -5,7 +5,7 @@ require 'rake/gempackagetask' spec = Gem::Specification.new do |s| s.platform = Gem::Platform::RUBY s.name = \u0026quot;simplegit\u0026quot; - s.version = \u0026quot;0.1.0\u0026quot; + s.version = \u0026quot;0.1.1\u0026quot; s.author = \u0026quot;Scott Chacon\u0026quot; s.email = \u0026quot;schacon@gee-mail.com\u0026quot; s.summary = \u0026quot;A simple gem for using Git in Ruby code.\u0026quot; commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test diff --git a/lib/simplegit.rb b/lib/simplegit.rb index a0a60ae..47c6340 100644 --- a/lib/simplegit.rb +++ b/lib/simplegit.rb @@ -18,8 +18,3 @@ class SimpleGit end end - -if $0 == __FILE__ - git = SimpleGit.new - puts git.show -end \\ No newline at end of file  \u0026ndash;stat，查看每次提交的简略的统计信息\n$ git log --stat commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test lib/simplegit.rb | 5 ----- 1 file changed, 5 deletions(-) commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit README | 6 ++++++ Rakefile | 23 +++++++++++++++++++++++ lib/simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+)  \u0026ndash;pretty。 指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用。\n$ git log --pretty=oneline ca82a6dff817ec66f44342007202690a93763949 changed the version number 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test a11bef06a3f659402fe7563abf99ad00de2209e6 first commit  但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着Git的更新而发生改变：\n$ git log --pretty=format:\u0026quot;%h - %an, %ar : %s\u0026quot; ca82a6d - Scott Chacon, 6 years ago : changed the version number 085bb3b - Scott Chacon, 6 years ago : removed unnecessary test a11bef0 - Scott Chacon, 6 years ago : first commit  git log \u0026ndash;pretty=format 常用的选项\n   选项 说明     %H 提交对象（commit）的完整哈希字串   %h 提交对象的简短哈希字串   %T 树对象（tree）的完整哈希字串   %t 树对象的简短哈希字串   %P 父对象（parent）的完整哈希字串   %p 父对象的简短哈希字串   %an 作者（author）的名字   %ae 作者的电子邮件地址   %ad 作者修订日期（可以用 \u0026ndash;date= 选项定制格式）   %ar 作者修订日期，按多久以前的方式显示   %cn 提交者(committer)的名字   %ce 提交者的电子邮件地址   %cd 提交日期   %cr 提交日期，按多久以前的方式显示   %s 提交说明    当 oneline 或 format 与另一个 log 选项 \u0026ndash;graph 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：\n$ git log --pretty=format:\u0026quot;%h %s\u0026quot; --graph * 2d3acf9 ignore errors from SIGCHLD on trap * 5e3ee11 Merge branch 'master' of git://github.com/dustin/grit |\\ | * 420eac9 Added a method for getting the current branch. * | 30e367c timeout code and tests * | 5a09431 add timeout protection to grit * | e1193f8 support for heads with slashes in them |/ * d6016bc require time for xmlschema * 11d191e Merge branch 'defunkt' into local  git log 的常用选项\n   选项 说明     -p 按补丁格式显示每个更新之间的差异。   \u0026ndash;stat 显示每次更新的文件修改统计信息。   \u0026ndash;shortstat 只显示 \u0026ndash;stat 中最后的行数修改添加移除统计。   \u0026ndash;name-only 仅在提交信息后显示已修改的文件清单。   \u0026ndash;name-status 显示新增、修改、删除的文件清单。   \u0026ndash;abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。   \u0026ndash;relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。   \u0026ndash;pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。    限制输出长度 除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。\n另外还有按照时间作限制的选项，比如 \u0026ndash;since 和 \u0026ndash;until 也很有用。 例如，下面的命令列出所有最近两周内的提交：\n$ git log --since=2.weeks  这个命令可以在多种格式下工作，比如说具体的某一天 \u0026ldquo;2008-01-15\u0026rdquo;，或者是相对地多久以前 \u0026ldquo;2 years 1 day 3 minutes ago\u0026rdquo;。\n另一个非常有用的筛选选项是 -S，可以列出那些添加或移除了某些字符串的提交。 比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：\n$ git log -Sfunction_name  限制 git log 输出的选项\n   选项 说明     -(n) 仅显示最近的 n 条提交   \u0026ndash;since, \u0026ndash;after 仅显示指定时间之后的提交。   \u0026ndash;until, \u0026ndash;before 仅显示指定时间之前的提交。   \u0026ndash;author 仅显示指定作者相关的提交。   \u0026ndash;committer 仅显示指定提交者相关的提交。   \u0026ndash;grep 仅显示含指定关键字的提交   -S 仅显示添加或移除了某个关键字的提交   \u0026ndash;all-match 显示满足所有匹配条件的提交   \u0026ndash;(path) 仅显示某些文件或者目录的提交（选项最后指定）    例子， 查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：\n$ git log --pretty=\u0026quot;%h - %s\u0026quot; --author=Junio Hamano --since=\u0026quot;2008-10-01\u0026quot; \\ --before=\u0026quot;2008-11-01\u0026quot; --no-merges -- t/ 5610e3b - Fix testcase failure when extended attributes are in use acd3b9e - Enhance hold_lock_file_for_{update,append}() API f563754 - demonstrate breakage of detached checkout with symbolic link HEAD d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths 51a94af - Fix \u0026quot;checkout --track -b newbranch\u0026quot; on detached HEAD b0ad11e - pull: allow \u0026quot;git pull origin $something:$current_branch\u0026quot; into an unborn branch  "});index.add({'id':74,'href':'/notes/docs/technology/program/RevisionControl/Git/configuration/','title':"Configuration",'content':"Git初始配置 #  Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：\n  /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 \u0026ndash;system 选项的 git config 时，它会从此文件读写配置变量。\n  ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 \u0026ndash;global 选项让 Git 读写此文件。\n  当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。\n  每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。\n用户信息 #  当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：\n$ git config --global user.name \u0026quot;CodeCC\u0026quot; $ git config --global user.email CodeCC@example.com  再次强调，如果使用了 \u0026ndash;global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 \u0026ndash;global 选项的命令来配置。\n很多 GUI 工具都会在第一次运行时帮助你配置这些信息。\n检查配置信息 #  如果想要检查你的配置，可以使用 git config \u0026ndash;list 命令来列出所有 Git 当时能找到的配置。\n$ git config --list user.name=CodeCC user.email=CodeCC@example.com ...  也可以通过输入 git config ： 来检查 Git 的某一项配置\n$ git config user.name CodeCC  "});index.add({'id':75,'href':'/notes/docs/technology/program/RevisionControl/Git/createNew/','title':"Create New",'content':"创建版本库 #    创建一个空目录\n $ cd /usr/local/src $ mkdir project    创建版本库\n  初始化\n $ git init Initialized empty Git repository in /usr/local/src/project/.git/    克隆现有仓库\n $ git clone [url]      添加文件\n $ git add README.md $ git commit -m 'first commit'    "});index.add({'id':76,'href':'/notes/docs/technology/program/RevisionControl/Git/install/','title':"Install",'content':"Git安装 #    yum安装\n $ sudo yum install git    源码安装\n依赖包安装\n $ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc xmlto docbook2x  从 https://www.kernel.org/pub/software/scm/git获取最新的版本包\n编译安装\n $ tar -zxf git-2.0.0.tar.gz $ cd git-2.0.0 $ make configure $ ./configure --prefix=/usr/local/git $ make all doc info $ sudo make install install-doc install-html install-info  升级\n $ git clone git://git.kernel.org/pub/scm/git/git.git   "});index.add({'id':77,'href':'/notes/docs/technology/program/RevisionControl/Git/introduce/','title':"Introduce",'content':"Git简介 #  git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。\n  特点\n  速度\n  简单的设计\n  对非线性开发模式的强力支持（允许成千上万个并行开发的分支）\n  完全分布式\n  有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）\n    三种状态[工作区域]\n  已提交(commit),[Git仓库]\n  已修改(modified),[工作目录]\n  已暂存(staged),[暂存区域]\n    基本工作流程\n  在工作目录中修改文件\n  暂存文件，将文件的快照放入暂存区域。\n  提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\n     "});index.add({'id':78,'href':'/notes/docs/technology/program/RevisionControl/Git/record/','title':"Record",'content':"记录更新 #  记录每次更新到仓库 #    文件状态\n  已跟踪文件\n  未修改\n  已修改\n  已放入暂存区\n    未跟踪文件\n    使用 Git 时文件的生命周期如下：\n  文件状态 #  git status 命令，用于查看哪些文件处于什么状态。\n已跟踪文件未被更改过，且没有处于未跟踪状态的新文件。会看到类似这样的输出：\n$ git status On branch master nothing to commit, working directory clean  存在新的未跟踪文件。会看到类似这样的输出：\n$ echo 'My Project' \u0026gt; README.md $ git status # On branch master # # Initial commit # # Untracked files: # (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed) # # README.md nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to track)   跟踪新文件 #  使用命令 git add 开始跟踪一个文件。\n$ git add README.md  存在已跟踪文件，并处于暂存状态。会看到类似这样的输出：\n# On branch master # # Initial commit # # Changes to be committed: # (use \u0026quot;git rm --cached \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # new file: README.md #   暂存已修改文件 #  已跟踪文件的内容发生了变化，但还没有放到暂存区。会看到类似这样的输出：\n$ git status # On branch master # Changes to be committed: # (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # new file: README.md # # Changed but not updated: # (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed) # (use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working directory) # # modified: CONTRIBUTING.md #  要暂存这次更新，需要运行 git add 命令。这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。\n$ git add CONTRIBUTING.md $ git status # On branch master # Changes to be committed: # (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # modified: CONTRIBUTING.md # new file: README.md #   状态简览 #  使用 git status -s 命令或 git status \u0026ndash;short 命令，获取一种更为紧凑的格式输出。 状态报告输出如下：\n$ git status -s M CONTRIBUTING.md A README.md ?? HELLO.md  状态标记详解\n??：新添加的未跟踪文件 A ：新添加到暂存区中的文件 M ：修改过得文件，并放入暂存区 M：修改过得文件，还未放入暂存区 MM：修改并提交到暂存区后又在工作区被修改   忽略文件 #  创建一个名为 .gitignore 的文件，列出要忽略的文件模式。\n$ cat .gitignore *.[oa] *~  文件 .gitignore 的格式规范如下：\n  所有空行或者以 # 开头的行都会被 Git 忽略。\n  可以使用标准的 glob 模式匹配。\n 星号（*）匹配零个或多个任意字符； [abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）; 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。    匹配模式可以以（/）开头防止递归。\n  匹配模式可以以（/）结尾指定目录。\n  要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。\n  我们再看一个 .gitignore 文件的例子：\n# no .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf  TIP GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 https://github.com/github/gitignore 找到它.\n 查看已暂存和未暂存的修改 #  git diff 命令，查看具体修改内容。 git diff 将通过文件补丁的格式显示具体哪些行发生了改变。\n查看尚未暂存的文件更新内容，直接输入 git diff：\n$ git diff diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md index 23509e0..90f904d 100644 --- a/CONTRIBUTING.md +++ b/CONTRIBUTING.md @@ -1,2 +1,3 @@ hello git +add con  此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。\n若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff \u0026ndash;cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff \u0026ndash;staged，效果是相同的，但更好记些。）\n$ git diff --staged diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md index ce01362..90f904d 100644 --- a/CONTRIBUTING.md +++ b/CONTRIBUTING.md @@ -1 +1,3 @@ hello +git +add con diff --git a/README.md b/README.md new file mode 100644 index 0000000..de369b6 --- /dev/null +++ b/README.md @@ -0,0 +1,2 @@ +My Project +abc  请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。\n 提交更新 #  现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit, 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：\n$ git commit -m 'modify file' [master d19800e] modify file 2 files changed, 4 insertions(+), 0 deletions(-) create mode 100644 README.md  好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。\n请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。\n 跳过使用暂存区域 #  尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：\n$ echo \u0026quot;follow me\u0026quot; \u0026gt;\u0026gt; CONTRIBUTING.md $ git status # On branch master # Changed but not updated: # (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed) # (use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working directory) # # modified: CONTRIBUTING.md # no changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;) $ git commit -a -m 'added new benchmarks' [master 3bcc140] added new benchmarks 1 files changed, 1 insertions(+), 0 deletions(-)   移除文件 #  要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。\n如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：\n$ rm project.md $ git status # On branch master # Changed but not updated: # (use \u0026quot;git add/rm \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed) # (use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working directory) # # deleted: project.md # no changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;)  然后再运行 git rm 记录此次移除文件的操作：\n$ git rm project.md rm 'project.md' $ git status # On branch master # Changes to be committed: # (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # deleted: project.md #  下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。\n另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 \u0026ndash;cached 选项：\n$ git rm --cached README  git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：\n$ git rm log/\\*.log  注意到星号 * 之前的反斜杠 \\， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：\n$ git rm \\*~  该命令为删除以 ~ 结尾的所有文件。\n 移动文件 #  不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。\n既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：\n$ git mv file_from file_to 它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：\n$ git mv README.md README # On branch master # Changes to be committed: # (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # renamed: README.md -\u0026gt; README #  其实，运行 git mv 就相当于运行了下面三条命令：\n$ mv README.md README $ git rm README.md $ git add README  如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，mv 是一条命令而另一种方式需要三条命令，直接用 git mv 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。\n"});index.add({'id':79,'href':'/notes/docs/technology/program/RevisionControl/Git/remote/','title':"Remote",'content':"远程仓库 #  远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。\n管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。\n 查看远程仓库 #  git remote ： 列出指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin\n$ git remote origin  指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。\n$ git remote -v origin https://github.com/Code-CC/leetcode (fetch) origin https://github.com/Code-CC/leetcode (push)   添加远程仓库 #  运行 git remote add   添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：\n$ git remote origin $ git remote add pb https://github.com/paulboone/ticgit $ git remote -v origin\thttps://github.com/schacon/ticgit (fetch) origin\thttps://github.com/schacon/ticgit (push) pb\thttps://github.com/paulboone/ticgit (fetch) pb\thttps://github.com/paulboone/ticgit (push)  现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：\n$ git fetch pb remote: Counting objects: 43, done. remote: Compressing objects: 100% (36/36), done. remote: Total 43 (delta 10), reused 31 (delta 5) Unpacking objects: 100% (43/43), done. From https://github.com/paulboone/ticgit * [new branch] master -\u0026gt; pb/master * [new branch] ticgit -\u0026gt; pb/ticgit   从远程仓库中抓取与拉取 #  从远程仓库中获得数据，可以执行：\n$ git fetch [remote-name]  这个命令会访问远程仓库，从中拉取所有你还没有的数据。（不进行合并分支）\n$ git pull [remote-name] [buranch-name]  这个命令会自动的抓取然后合并远程分支到当前分支。\n 推送到远程仓库 #  当你想分享你的项目时，必须将其推送到上游。可以使用下面的命令：\ngit push [remote-name] [branch-name]  只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。\n 查看远程仓库 #  git remote show [remote-name] ：查看远程仓库信息。\n$ git remote show origin * remote origin Fetch URL: https://github.com/Code-CC/leetcode Push URL: https://github.com/Code-CC/leetcode HEAD branch: master Remote branch: master tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (local out of date)  它同样会列出远程仓库的 URL 与跟踪分支的信息。\n 远程仓库的移除与重命名 #  git remote rename ：修改一个远程仓库的简写名。\n$ git remote rename pb paul $ git remote origin paul  git remote rm ：移除一个远程仓库\n$ git remote rm paul $ git remote origin   "});index.add({'id':80,'href':'/notes/docs/technology/program/RevisionControl/Git/tag/','title':"Tag",'content':"打标签 #  Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。\n 列出标签 #  git tag：列出已有的标签\n$ git tag v0.1 v1.3  git tag -l ：使用特定的模式查找标签。\n$ git tag -l 'v1.8.5*' v1.8.5 v1.8.5-rc0 v1.8.5-rc1 v1.8.5-rc2 v1.8.5-rc3 v1.8.5.1 v1.8.5.2 v1.8.5.3 v1.8.5.4 v1.8.5.5   创建标签 #  Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。\n一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。\n然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。\n  附注标签\ngit tag -a ：添加一个附注标签。\n $ git tag -a v1.4 -m 'my version 1.4' $ git tag v0.1 v1.3 v1.4  -m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。\ngit show 命令可以看到标签信息与对应的提交信息：\n $ git show v1.4 tag v1.4 Tagger: Ben Straub \u0026lt;ben@straub.cc\u0026gt; Date: Sat May 3 20:19:12 2014 -0700 my version 1.4 commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number    轻量标签\n $ git tag v1.4-lw $ git tag v0.1 v1.3 v1.4 v1.4-lw v1.5  这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n $ git show v1.4-lw commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number    后期打标签\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n $ git log --pretty=oneline 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment' a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support 0d52aaab4479697da7686c15f77a3d64d9165190 one more thing 6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment' 0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function 4682c3261057305bdd616e23b64b0857d832627b added a todo file 166ae0c4d3f420721acbb115cc33848dfcc2121a started write support 9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile 964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo 8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme  现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:\n $ git tag -a v1.2 9fceb02 $ git tag v0.1 v1.2 v1.3 v1.4 v1.4-lw v1.5 $ git show v1.2 tag v1.2 Tagger: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Feb 9 15:32:16 2009 -0800 version 1.2 commit 9fceb02d0ae598e95dc970b74767f19372d61af8 Author: Magnus Chacon \u0026lt;mchacon@gee-mail.com\u0026gt; Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile ...     共享标签 #  默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。\n$ git push origin v1.5 Counting objects: 14, done. Delta compression using up to 8 threads. Compressing objects: 100% (12/12), done. Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done. Total 14 (delta 3), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.5 -\u0026gt; v1.5  如果想要一次性推送很多标签，也可以使用带有 \u0026ndash;tags 选项的 git push 命令。\n$ git push origin --tags Counting objects: 1, done. Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done. Total 1 (delta 0), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.4 -\u0026gt; v1.4 * [new tag] v1.4-lw -\u0026gt; v1.4-lw   检出标签 #  在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支：\n$ git checkout -b version2 v2.0.0 Switched to a new branch 'version2'  当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。\n "});index.add({'id':81,'href':'/notes/docs/technology/program/RevisionControl/Git/undo/','title':"Undo",'content':"撤消操作 #  重新提交 #  \u0026ndash;amend 选项的提交命令尝试重新提交：\n$ git commit --amend  这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。\n例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n$ git commit -m 'initial commit' $ git add forgotten_file $ git commit --amend  最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。\n 取消暂存的文件 #  $ git add * $ git status # On branch master # Changes to be committed: # (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # modified: CONTRIBUTING.md # modified: README #  git rest HEAD  取消暂存：\n$ git reset HEAD CONTRIBUTING.md Unstaged changes after reset: M CONTRIBUTING.md $ git status # On branch master # Changes to be committed: # (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # modified: README # # Changed but not updated: # (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed) # (use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working directory) # # modified: CONTRIBUTING.md #   撤消对文件的修改 #  git checkout \u0026ndash;  ， 将它还原成上次提交时的样子：\n$ git checkout -- CONTRIBUTING.md $ git status # On branch master # Changes to be committed: # (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) # # modified: README #   "});index.add({'id':82,'href':'/notes/docs/technology/program/RevisionControl/README/','title':"R E a D M E",'content':"版本控制 #  什么是“版本控制”？ #  版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。\n如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。\n 分类 #    本地版本控制系统\n许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。\n为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。\n 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。\n  集中化的版本控制系统\n接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、 Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。\n 这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。\n事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n  分布式版本控制系统\n于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n 更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。\n  "});index.add({'id':83,'href':'/notes/docs/technology/program/Shell/README/','title':"R E a D M E",'content':"Shell #  基础语法 #    变量\n  函数\n   进阶 #    代码风格  "});index.add({'id':84,'href':'/notes/docs/technology/security/Basic/README/','title':"R E a D M E",'content':"安全基础 #  密码学 #  密码学处理数字和字符串。\n哈希 #  哈希散列是一项密码学技术，它将数据转换成其他形式，并且不可恢复。\n加解密 #  加解密是一个双向过程，当且仅当加密密钥被知道时才能检索原始数据。\n对称加密 #  对称加密使用同一个密钥\n非对称加密 #  非对称加密使用公私钥，私钥自己持有，公钥给所有想加密信息发送给你的人。使用公钥加密，使用私钥解密。\n"});index.add({'id':85,'href':'/notes/docs/technology/security/Firewall/firewalld/','title':"Firewalld",'content':"Firewalld #  firewalld是CentOS7默认的防火墙服务，用于管理网络数据包的流动和转发。\n 基础命令 #    启动\n $ systemctl start firewalld.service    查看状态\n $ systemctl status firewalld.service    关闭\n $ systemctl stop firewalld.service    开启和关闭开机启动\n $ systemctl enable firewalld.service $ systemctl disable firewalld.service    Rule配置：firewall-cmd命令\n   Options Description     -h, \u0026ndash;help Prints a short help text and exists   -V, \u0026ndash;version Print the version string of firewalld   -q, \u0026ndash;quiet Do not print status messages   \u0026ndash;state Return and print firewalld state   \u0026ndash;reload Reload firewall and keep state information   \u0026ndash;complete-reload Reload firewall and loose state information   \u0026ndash;runtime-to-permanent Create permanent from runtime configuration   \u0026ndash;permanent Set an option permanently   \u0026ndash;zone=\u0026lt;zone\u0026gt; Use this zone to set or query options, else default zone   \u0026ndash;timeout=\u0026lt;timeval\u0026gt; Enable an option for timeval time, where timeval is,a number followed by one of letters \u0026rsquo;s\u0026rsquo; or \u0026rsquo;m\u0026rsquo; or \u0026lsquo;h\u0026rsquo;       概念 #  区域(Zones) #  一个规则管理群组的概念，定义了可信任级别。其中预先定义的zones有以下几个：\n  drop\n最低信任级别，任何流入网络的包都被丢弃，不作出任何响应。只允许流出的网络连接。\n  block\n任何进入的网络连接都被拒绝，并返回 IPv4 的 icmp-host-prohibited 报文或者 IPv6 的 icmp6-adm-prohibited 报文。只允许由该系统初始化的网络连接。\n  public\n用以可以公开的部分。你认为网络中其他的计算机不可信并且可能伤害你的计算机。只允许选中的连接接入。\n  external\n用在路由器等启用伪装的外部网络。你认为网络中其他的计算机不可信并且可能伤害你的计算机。只允许选中的连接接入。\n  internal\n用在内部网络。你信任网络中的大多数计算机不会影响你的计算机。只接受被选中的连接。\n  dmz\n用以允许隔离区（dmz）中的电脑有限地被外界网络访问。只接受被选中的连接。\n  work\n用在工作网络。你信任网络中的大多数计算机不会影响你的计算机。只接受被选中的连接。\n  home\n用在家庭网络。你信任网络中的大多数计算机不会影响你的计算机。只接受被选中的连接。\n  trusted\n允许所有网络连接。\n  服务(service) #  服务是端口和/或协议入口的组合。备选内容包括 netfilter 助手模块以及 IPv4、IPv6地址。\n端口和协议(port/protocol) #  定义了 tcp 或 udp 端口，端口可以是一个端口或者端口范围。\nICMP阻塞 #  可以选择 Internet 控制报文协议的报文。这些报文可以是信息请求亦可是对信息请求或错误条件创建的响应.\n伪装 #  私有网络地址可以被映射到公开的IP地址。这是一次正规的地址转换。\n端口转发 #  端口可以映射到另一个端口以及/或者其他主机。\n 配置文件 #    区域配置文件\n /usr/lib/firewalld/zones(原始文件目录)    配置文件目录\n /etc/firewalld/zones    配置文件格式\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;zone\u0026gt; \u0026lt;short\u0026gt;Public\u0026lt;/short\u0026gt; \u0026lt;!--区域名称--\u0026gt; \u0026lt;description\u0026gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.\u0026lt;/description\u0026gt; \u0026lt;service name=\u0026quot;dhcpv6-client\u0026quot;/\u0026gt; \u0026lt;service name=\u0026quot;ssh\u0026quot;/\u0026gt; \u0026lt;!--服务名称,调用ssh服务配置文件--\u0026gt; \u0026lt;port protocol=\u0026quot;tcp\u0026quot; port=\u0026quot;2222\u0026quot;/\u0026gt; \u0026lt;!--协议、端口--\u0026gt; \u0026lt;/zone\u0026gt;      服务配置文件\n /usr/lib/firewalld/services (原始文件目录)    配置文件目录\n /etc/firewalld/zones (zones优先调用目录)    配置文件格式\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;service\u0026gt; \u0026lt;short\u0026gt;SSH\u0026lt;/short\u0026gt; \u0026lt;!--服务名称--\u0026gt; \u0026lt;description\u0026gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.\u0026lt;/description\u0026gt; \u0026lt;port protocol=\u0026quot;tcp\u0026quot; port=\u0026quot;22\u0026quot;/\u0026gt; \u0026lt;!--配置协议端口--\u0026gt; \u0026lt;/service\u0026gt;      "});index.add({'id':86,'href':'/notes/docs/technology/security/Firewall/iptables/','title':"Iptables",'content':"Iptables #  iptables：一个运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送。\nNetfilter：Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：\n  网络地址转换(Network Address Translate)\n  数据包内容修改\n  数据包过滤\n  Netfilter的配置表：存放设置的规则的文件，存放在内核内存中。iptables程序通过修改这个规则文件来控制网络数据包流动。 该配置表由表tables、链chains、规则rules组成。\n Netfilter配置表 #  表(tables) #  用于实现特定的功能\n  raw表\n主要用于决定数据包是否被状态跟踪机制处理。在匹配数据包时，raw表的规则要优先于其他表。包含两条规则链 OUTPUT、PREROUTING。\niptables中数据包和4种被跟踪连接的4种不同状态：\n NEW：该包想要开始一个连接（重新连接或将连接重定向） RELATED：该包是属于某个已经建立的连接所建立的新连接。 ESTABLISHED ：只要发送并接到应答，一个数据连接从NEW变为ESTABLISHED,而且该状态会继续匹配这个连接的后续数据包。 INVALID：数据包不能被识别属于哪个连接或没有任何状态比如内存溢出，收到不知属于哪个连接的ICMP错误信息，一般应该DROP这个状态的任何数据。    mangle表\n主要用于修改数据包的TOS（Type Of Service，服务类型）、TTL（Time To Live，生存周期）指以及为数据包设置Mark标记，以实现Qos(Quality Of Service，服务质量)调整以及策略路由等应用，由于需要相应的路由设备支持，因此应用并不广泛。包含五个规则链——PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD。\n  nat表\n主要用于修改数据包的IP地址、端口号等信息（网络地址转换，如SNAT、DNAT、MASQUERADE、REDIRECT）。属于一个流的包(因为包 的大小限制导致数据可能会被分成多个数据包)只会经过这个表一次。如果第一个包被允许做NAT或Masqueraded，那么余下的包都会自动地被做相同的操作，也就是说，余下的包不会再通过这个表。\n表对应的内核模块为 iptable_nat，包含三个链：\n PREROUTING链：作用是在包刚刚到达防火墙时改变它的目的地址 OUTPUT链：改变本地产生的包的目的地址 POSTROUTING链：在包就要离开防火墙之前改变其源地址    filter表\n主要用于对数据包进行过滤，根据具体的规则决定是否放行该数据包（如DROP、ACCEPT、REJECT、LOG）。filter 表对应的内核模块为iptable_filter，包含三个规则链：\n INPUT链：INPUT针对那些目的地是本地的包 FORWARD链：FORWARD过滤所有不是本地产生的并且目的地不是本地(即本机只是负责转发)的包 OUTPUT链：OUTPUT是用来过滤所有本地生成的包    链(chains) #  在处理各种数据包时，根据防火墙规则的不同介入时机，iptables供涉及5种默认规则链，从应用时间点的角度理解这些链：\n  INPUT链：当接收到防火墙本机地址的数据包（入站）时，应用此链中的规则。\n  OUTPUT链：当防火墙本机向外发送数据包（出站）时，应用此链中的规则。\n  FORWARD链：当接收到需要通过防火墙发送给其他地址的数据包（转发）时，应用此链中的规则。\n  PREROUTING链：在对数据包作路由选择之前，应用此链中的规则，如DNAT。\n  POSTROUTING链：在对数据包作路由选择之后，应用此链中的规则，如SNAT。\n  规则(rules) #    ACCEPT：允许数据包通过\n  DROP：直接丢弃数据包，不给任何回应信息\n  REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息。\n  SNAT：源地址转换。在进入路由层面的route之前，重新改写源地址，目标地址不变，并在本机建立NAT表项，当数据返回时，根据NAT表将 目的地址数据改写为数据发送出去时候的源地址，并发送给主机。解决内网用户用同一个公网地址上网的问题。 MASQUERADE，是SNAT的一种特殊形式，适用于像adsl这种临时会变的ip上\n  DNAT:目标地址转换。和SNAT相反，IP包经过route之后、出本地的网络栈之前，重新修改目标地址，源地址不变，在本机建立NAT表项，当 数据返回时，根据NAT表将源地址修改为数据发送过来时的目标地址，并发给远程主机。可以隐藏后端服务器的真实地址。 REDIRECT：是DNAT的一种特殊形式，将网络包转发到本地host上（不管IP头部指定的目标地址是啥），方便在本机做端口转发。\n  LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则\n  除去最后一个LOG，前3条规则匹配数据包后，该数据包不会再往下继续匹配了，所以编写的规则顺序极其关键。\n 原理 #     从上图中，我们可以总结出以下规律：\n  一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转发出去。\n  如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经 过OUTPUT链，然后到达POSTROUTING链输出。\n  如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD链，然后到达POSTROUTING链输出。\n   规则编写 #  命令格式：iptables -t TABLE command CHAIN parameter match -j TARGET\n    command 描述     -P \u0026ndash;policy 定义默认策略   -L \u0026ndash;list 查看iptables规则列表   -A \u0026ndash;append 在规则列表的最后增加1条规则   -I \u0026ndash;insert 在指定的位置插入1条规则   -D \u0026ndash;delete 从规则列表中删除1条规则   -R \u0026ndash;replace 替换规则列表中的某条规则   -F \u0026ndash;flush 删除表中所有规则   -Z \u0026ndash;zero 将表中数据包计数器和流量计数器归零   -X \u0026ndash;delete-chain 删除自定义链   -v \u0026ndash;verbose 与-L他命令一起使用显示更多更详细的信息   -nL 查看当前运行的防火墙规则列表       parameter match 描述     -i \u0026ndash;in-interface 网络接口名\u0026gt; 指定数据包从哪个网络接口进入，   -o \u0026ndash;out-interface 网络接口名\u0026gt; 指定数据包从哪个网络接口输出   -p \u0026mdash;proto 协议类型 指定数据包匹配的协议，如TCP、UDP和ICMP等   -s \u0026ndash;source 源地址或子网\u0026gt; 指定数据包匹配的源地址   \u0026ndash;sport 源端口号\u0026gt; 指定数据包匹配的源端口号   -d \u0026ndash;destination 目的地址或子网\u0026gt; 指定数据包匹配的目的地址   \u0026ndash;dport 目的端口号\u0026gt; 指定数据包匹配的目的端口号   -m \u0026ndash;match 匹配的模块 指定数据包规则所使用的过滤模块    -m：extend matches，这个选项用于提供更多的匹配参数，如：\n-m state –-state ESTABLISHED,RELATED -m tcp –-dport 22 -m multiport –-dports 80,8080 -m icmp –-icmp-type 8   "});index.add({'id':87,'href':'/notes/docs/technology/security/Firewall/README/','title':"R E a D M E",'content':"防火墙 #  工作在主机或网络边缘，对进出的报文按事先定义的规则进行检查，并且由匹配到的规则进行处理的一组硬件或软件，甚至可能是二者的结合。\n Linux防火墙 #     iptables\n   firewalld\n  "});index.add({'id':88,'href':'/notes/docs/technology/security/IDS/README/','title':"R E a D M E",'content':"IDS #  入侵检测系统\n HIDS #  OSSEC\nNIDS #  snort\nFiresystem #  tripware\n"});index.add({'id':89,'href':'/notes/docs/technology/security/IDS/Snort/snort/','title':"Snort",'content':"Snort #  #  "});index.add({'id':90,'href':'/notes/docs/technology/security/TLS/ssl/','title':"Ssl",'content':"SSL协议 #  SSL是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。\n   SSL介绍\n   工作机制\n   工具使用\n   SSL介绍 一个简单的工作流程: #    浏览器请求一个安全页面(https://)。\n  Web服务器返回公钥及其证书。\n  浏览器检查该证书是否由可信任的机构颁发，并且是与站点相关的有效证书。\n  浏览器使用公钥加密随即对称加密密钥，和通过随即加密密钥加密的http数据一同发送给Web服务器。\n  Web服务器通过私钥解密随即对称加密密钥，并使用它解密http数据。\n  Web服务器返回通过随即对称加密密钥加密的请求html文本和http数据。\n  浏览器通过随即对称加密密钥解密html文本和http数据并展示信息。\n   公私钥: #  非对称加密，使用私钥/公钥对加密，数据可以被一个密钥加密，但只能被另一个密钥对解密。该密钥对自己保留一个私钥，并将公钥分配给每个人。\nMessage --\u0026gt; [Public Key] --\u0026gt; Encrypted Message --\u0026gt; [Private Key] --\u0026gt; Message   证书: #  证书加载在浏览器或者其他客户端党当中，证书包含了证书所有者的信息。一个例子:\nCertificate: Data: Version: 3 (0x2) Serial Number: 1 (0x1) Signature Algorithm: md5WithRSAEncryption Issuer: C=FJ, ST=Fiji, L=Suva, O=SOPAC, OU=ICT, CN=SOPAC Root CA/Email=administrator@sopac.org Validity Not Before: Nov 20 05:47:44 2001 GMT Not After : Nov 20 05:47:44 2002 GMT Subject: C=FJ, ST=Fiji, L=Suva, O=SOPAC, OU=ICT, CN=www.sopac.org/Email=administrator@sopac.org Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (1024 bit) Modulus (1024 bit): 00:ba:54:2c:ab:88:74:aa:6b:35:a5:a9:c1:d0:5a: 9b:fb:6b:b5:71:bc:ef:d3:ab:15:cc:5b:75:73:36: b8:01:d1:59:3f:c1:88:c0:33:91:04:f1:bf:1a:b4: 7a:c8:39:c2:89:1f:87:0f:91:19:81:09:46:0c:86: 08:d8:75:c4:6f:5a:98:4a:f9:f8:f7:38:24:fc:bd: 94:24:37:ab:f1:1c:d8:91:ee:fb:1b:9f:88:ba:25: da:f6:21:7f:04:32:35:17:3d:36:1c:fb:b7:32:9e: 42:af:77:b6:25:1c:59:69:af:be:00:a1:f8:b0:1a: 6c:14:e2:ae:62:e7:6b:30:e9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: FE:04:46:ED:A0:15:BE:C1:4B:59:03:F8:2D:0D:ED:2A:E0:ED:F9:2F X509v3 Authority Key Identifier: keyid:E6:12:7C:3D:A1:02:E5:BA:1F:DA:9E:37:BE:E3:45:3E:9B:AE:E5:A6 DirName:/C=FJ/ST=Fiji/L=Suva/O=SOPAC/OU=ICT/CN=SOPAC Root CA/Email=administrator@sopac.org serial:00 Signature Algorithm: md5WithRSAEncryption 34:8d:fb:65:0b:85:5b:e2:44:09:f0:55:31:3b:29:2b:f4:fd: aa:5f:db:b8:11:1a:c6:ab:33:67:59:c1:04:de:34:df:08:57: 2e:c6:60:dc:f7:d4:e2:f1:73:97:57:23:50:02:63:fc:78:96: 34:b3:ca:c4:1b:c5:4c:c8:16:69:bb:9c:4a:7e:00:19:48:62: e2:51:ab:3a:fa:fd:88:cd:e0:9d:ef:67:50:da:fe:4b:13:c5: 0c:8c:fc:ad:6e:b5:ee:40:e3:fd:34:10:9f:ad:34:bd:db:06: ed:09:3d:f2:a6:81:22:63:16:dc:ae:33:0c:70:fd:0a:6c:af: bc:5a -----BEGIN CERTIFICATE----- MIIDoTCCAwqgAwIBAgIBATANBgkqhkiG9w0BAQQFADCBiTELMAkGA1UEBhMCRkox DTALBgNVBAgTBEZpamkxDTALBgNVBAcTBFN1dmExDjAMBgNVBAoTBVNPUEFDMQww CgYDVQQLEwNJQ1QxFjAUBgNVBAMTDVNPUEFDIFJvb3QgQ0ExJjAkBgkqhkiG9w0B CQEWF2FkbWluaXN0cmF0b3JAc29wYWMub3JnMB4XDTAxMTEyMDA1NDc0NFoXDTAy MTEyMDA1NDc0NFowgYkxCzAJBgNVBAYTAkZKMQ0wCwYDVQQIEwRGaWppMQ0wCwYD VQQHEwRTdXZhMQ4wDAYDVQQKEwVTT1BBQzEMMAoGA1UECxMDSUNUMRYwFAYDVQQD Ew13d3cuc29wYWMub3JnMSYwJAYJKoZIhvcNAQkBFhdhZG1pbmlzdHJhdG9yQHNv cGFjLm9yZzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAulQsq4h0qms1panB 0Fqb+2u1cbzv06sVzFt1cza4AdFZP8GIwDORBPG/GrR6yDnCiR+HD5EZgQlGDIYI 2HXEb1qYSvn49zgk/L2UJDer8RzYke77G5+IuiXa9iF/BDI1Fz02HPu3Mp5Cr3e2 JRxZaa++AKH4sBpsFOKuYudrMOkCAwEAAaOCARUwggERMAkGA1UdEwQCMAAwLAYJ YIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENlcnRpZmljYXRlMB0GA1Ud DgQWBBT+BEbtoBW+wUtZA/gtDe0q4O35LzCBtgYDVR0jBIGuMIGrgBTmEnw9oQLl uh/anje+40U+m67lpqGBj6SBjDCBiTELMAkGA1UEBhMCRkoxDTALBgNVBAgTBEZp amkxDTALBgNVBAcTBFN1dmExDjAMBgNVBAoTBVNPUEFDMQwwCgYDVQQLEwNJQ1Qx FjAUBgNVBAMTDVNPUEFDIFJvb3QgQ0ExJjAkBgkqhkiG9w0BCQEWF2FkbWluaXN0 cmF0b3JAc29wYWMub3JnggEAMA0GCSqGSIb3DQEBBAUAA4GBADSN+2ULhVviRAnw VTE7KSv0/apf27gRGsarM2dZwQTeNN8IVy7GYNz31OLxc5dXI1ACY/x4ljSzysQb xUzIFmm7nEp+ABlIYuJRqzr6/YjN4J3vZ1Da/ksTxQyM/K1ute5A4/00EJ+tNL3b Bu0JPfKmgSJjFtyuMwxw/Qpsr7xa -----END CERTIFICATE-----  该证书包含对发行人的引用，该证书的所有者的公钥，该证书的有效期和证书的签名，以确保该证书没有被篡改。\n 对称密钥: #  对称加密，使用相同密钥进行加密和解密。对称加密在处理速度上比非对称加密快，但安全性低。综合考虑，使用公私钥加解密对称密钥，在每次事务都选择不同的对称密钥是更安全和高效的方案。\nSymetric Key --\u0026gt; [Public Key] --\u0026gt; Encrypted Symetric Key --\u0026gt; [Private Key] --\u0026gt; Symetric Key   加密算法: #  加密算法有对称和非对称方法，使用不同长度的密钥。\n Hash #  哈希是由消息中的哈希函数给出的数字。 这是一个单向函数，这意味着不可能得到原始消息知道哈希。 然而，即使消息中最轻微的修改，哈希也会发生巨大变化。 因此，在保持其原始散列的同时修改消息是非常困难的。它也被成为消息摘要。哈希函数用于密码机制，用于证明应用程序是原始的（MD5总和），确保任何消息未被篡改。\n 签名 #  签署信息意味着验证您已经确定了邮件的真实性。要签署消息，需要创建其Hash，然后使用私钥加密Hash，然后添加加密Hash和签名的证书与消息。 收件人将重新创建消息hash，使用签名的证书中存储的公钥解密加密Hash，检查两个Hash是否相等，最后检查证书。\n PassPhrase #  PassPhrase就像一个密码，除了它更长。\n PKI #  Public Key Infrastructure（PKI）是软件管理系统和数据库系统，允许签署证书，保留撤销证书清单，分发公钥。\n CSRs #  要从CA获取SSL证书，就要生成一个certificate signing request (CSR)。CSR由密钥对的公钥和一些附加信息组成。这两个组件在签名时都会插入证书。\n生成CSR需要填入的信息：\n--- Country Name (2 letter code) [AU]:US State or Province Name (full name) [Some-State]:New York Locality Name (eg, city) []:Brooklyn Organization Name (eg, company) [Internet Widgits Pty Ltd]:Example Brooklyn Company Organizational Unit Name (eg, section) []:Technology Division Common Name (e.g. server FQDN or YOUR name) []:examplebrooklyn.com Email Address []:   工作机制 TLS协议由两部分组成，包括（TLS Record Layer,TLS handshake protocol）\n  Record Layer:\n为每条信息提供一个header和在尾部生成一个从Message Authentication Code (MAC) 得到的hash值，其中header由5 bytes组成，分别是协议说明(1bytes),协议版本(2bytes)和长度(2bytes)，跟在header后面的协议信息长度不得超过16384bytes。\n  Handshake Protocol:\nTLS握手:\n    OpenSSl工具 OpenSSL是一个通用的命令行工具，可用于与公钥基础设施（PKI）和HTTPS（TLS over HTTP）相关的各种任务。\n生成CSRs #  #生成一个私钥和一个CSR openssl req -newkey rsa:2048 -nodes -keyout domain.key -out domain.csr #使用已存在的私钥生成CSR openssl req -key domain.key -new -out domain.csr   生成SSL证书 #  #生成一个私钥和自签名证书 openssl req -newkey ras:2048 -keyout domain.key -x509 -days 365 -out domain.crt #使用已存在的私钥生成自签名证书 openssl req -key domain.key -x509 -days 365 -out domain.crt #使用已存在的私钥和CSR生成自签名证书 openssl x509 -signkey domain.key -in domain.csr -req -days 365 -out domain.crt   查看证书 #  #查看CSR信息 openssl req -text -noout -verify -in domain.csr #查看证书信息 openssl x509 -text -noout -in domain.crt #验证证书是呦CA签署的 openssl verify -verbose -CAFile ca.crt domain.crt   生成私钥 #  #创建私钥文件 openssl genrsa -des3 -out domain.key 2048 #查看私钥信息 openssl rsa -check -in domain.key   证书格式转换 #  #PEM转DER openssl x509 -in domain.crt -outform der -out domain.der #DER转PEM openssl x509 -inform der -in domain.der -out domain.crt #PEM转PKCS7 openssl crl2pkcs7 -nocrl -certfile domain.crt -certfile ca-chain.crt -out domain.p7b #PKCS7转PEM openssl pkcs7 -in domain.p7b -print_certs -out domain.crt #PEM转PKCS12 openssl pkcs12 -inkey domain.key -in domain.crt -export -out domain.pfx #PKCS12转PEM openssl pkcs12 -in domain.pfx -nodes -out domain.combined.crt "});index.add({'id':91,'href':'/notes/docs/technology/system/Application/nginx/','title':"Nginx",'content':"Nginx #  概念 #  Nginx是一个开源免费的web服务器，同时可以作为反向代理、负载均衡和HTTP缓存的软件。\nNginx架构 #  "});index.add({'id':92,'href':'/notes/docs/technology/system/Application/ssh/','title':"Ssh",'content':"SSH #  概念 #  安全Shell（SSH）是一种加密网络协议，用于通过无安全网络安全地运行网络服务。\nSSH协议 #    认证\n  加密\n  完整性\n  SSH属性 #    安全远程登录(Secure Remote Login )\n  安全文件传输(Secure File Transfer)\n  安全远程命令执行(Secure Remote Command Execution)\n  密钥和代理(Keys and Agents)\n  访问控制(Access Control)\n  端口转发(Port Forwarding)\n  架构 #    基础操作 #    远程登录\nssh -l USERNAME HOST -p PORT\n  文件传输\nscp SOURCE DESTINATION\n  已知主机(known hosts)\nknown hosts可以用来防止中间人攻击。 每个SSH服务器都有一个秘密的唯一ID，称为主机密钥(host key)，用于向客户端标识自身。当首次连接的时，ssh会记录目标设备的host key到~/.ssh/known_hosts文件，当主机密钥发生改变时，在连接时将会有提示告警。\n  转义字符(The Escape Character)\n转义字符可以用于暂时中断连接，默认符号为\u0026quot;~\u0026rdquo; 也可以自行进行更改，使用-e选项，ssh -e \u0026ldquo;#\u0026rdquo; HOST\n  加密密钥认证(Authentication by Cryptographic Key) #  密码认证方式的缺陷：\n 安全的密码复杂性高，难于记忆。 通过网络传输密码还是会有被捕获的风险。  SSH支持公钥认证的方式，可以解决上述的密码问题。\n 密钥简介  key是一个数字身份，是一个独特的二进制字符串。\nSSH身份使用一对密钥，一个私有密钥和一个公有密钥。私钥由自身保管，公钥保存在需要访问的ssh服务器上。(~/.ssh/authorized_keys)文件。\nclient请求登录server server要求身份认证 client发送自身私钥证明自己身份 server使用公钥对私钥进行匹配，成功则允许登录。   ssh-keygen生成密钥对\n(ssh-keygen -t dsa|rsa) | (ssh-keygen) 会在~/.ssh/目录生成id_rsa和id_rsa.pub两个文件\n  在ssh服务器上安装公钥\n 直接编辑~/.ssh/authorized_keys(权限644),拷贝id_rsa.pub的内容到该文件 使用ssh-copy-id ssh-copy-id -i id_rsa.pub [user@]server_name     SSH深入 #    加密\n  完整性\n  认证\n  授权\n  转发\n  密码学入门 #  "});index.add({'id':93,'href':'/notes/docs/technology/system/Application/tomcat/','title':"Tomcat",'content':"Tomcat #  "});index.add({'id':94,'href':'/notes/docs/technology/system/Linux/GuideBook/fileOperation/','title':"File Operation",'content':"一切皆文件 #    列出文件列表\n ls [option] /PATH #不指定路径，默认为当前路径 option -l:长格式 文件类型: -:普通文件 d:目录文件 b:块设备文件（block） c：字符设备文件（character） l：符号链接文件（symbolic link file） p：命令管道（pipe） s：套接字文件（socket） 文件权限：9位，每三位一组(u-g-o),每一组：rwx（读、写、执行） 文件硬链接的次数 文件的属主(owner) 文件的属组(group) 文件的大小(size)，单位是字节 时间戳(timestamp)：最近一次被修改的时间 访问：access 修改：modify，文件内容发生改变 改变：change，metadata，元数据 文件名 -h:做单位转换，默认bit -a:显示以.开头的隐藏文件 . 表示当前目录 .. 表示父目录 -d：显示目录自身属性 -i：index node，inode -r：逆序显示文件 -R：递归(recursive)显示    进入目录\n cd /PATH cd ~USERNAME:进入指定用户的家目录 cd -:在当前目录和前一次所在目录之间来回切换    显示文件类型\n type /PATH/FILENAME    显示当前路径\n pwd    目录管理\n  创建空目录\n mkdir [option] /PATH option -p:若父目录不存在，则自动创建 -v:列出过程详细信息 -m:指定目录权限    删除空目录\n rmdir /PATH      文件管理\n  创建文件\n touch [option] /PATH option:若文件存在 -a:修改访问时间 -m:修改修改时间 -c:修改改变时间    查看文件状态\n stat /PATH    删除文件\n rm [option] /PATH option -i:提示 -f:强制删除，不提示 -r:递归删除    复制文件\n cp [option] SRC DEST option -r:递归 -i:提示是否覆盖 -p:保留属性 -a:归档复制，保留所有属性    移动文件\n mv SRC DEST      文本查看\n  连接并显示\n cat [option] /PATH/FILENAME option -n:显示行号 -E:显示行尾    分屏显示\n more /PATH/FILENAME less /PATH/FILENAME head [option] /PATH/FILENAME option -n number:显示前n行 tail [option] /PATH/FILENAME option -n number:显示后n行 -f:查看文件尾部，不退出，等待显示后续追加至此文件的新内容      文本处理\n  文本分割\n cut [option] /PATH/FILENAME option -d:指定分隔符，默认是空格 -f number:指定要显示的字段    文本排序\n sort [option] /PATH/FILENAME option -n:数值排序 -r:降序 #默认为升序 -t:字段分隔符 -k:以哪个字段为关键字进行排序 -u:排序后相同的行只显示一次    文本去重\n uniq [option] /PATH/FILENAME option -c:只显示文件中行重复的次数 -d:只显示重复的行    文本统计\n wc [option] /PATH/FILENAME option -l:统计行数 -w:统计单词数 -c:统计字符数 -L:打印最长的行    字符转换\n tr [option] SET1 [SET2] option -d:删除出现在字符集中的所有字符      "});index.add({'id':95,'href':'/notes/docs/technology/system/Linux/GuideBook/permissionsOperation/','title':"Permissions Operation",'content':"权限操作 #  权限 #    可读(r)(4)\n  可写(w)(2)\n  可执行(x)(1)\n  特殊权限\n  SUID(u+s): 运行某程序时，相应进程的属主是程序文件自身的属主\n  SGID(g+s)：运行某程序时，相应进程的属组是程序文件自身的属组\n  Sticky(o+t)：在一个公共目录，每个用户都可以创建删除自己的文件，但不能删除别人的文件\n     用户和组 #    用户(UID)\n  类别\n  管理员：0\n  普通用户：1-65535\n  系统用户：1-499\n  一般用户：500-65535\n      配置文件\n  /etc/passwd\n字段详解(以\u0026rdquo;:\u0026ldquo;为分割符)\n用户名 : 密码 : UID : GID : 注释 : 家目录 : 默认shell\n  /etc/shadow\n字段详解(以\u0026rdquo;:\u0026ldquo;为分隔符)\n用户名 : 密码 : 最近一次修改密码时间 : 最短使用期限 : 最长使用期限 : 警告时间 : 非活动时间 : 过期时间\n      组(GID)\n  类别\n  私有组：创建用户时，没指定所组，则系统默认创建同名组\n  基本组：用户的默认组\n  附加组：\n    配置文件\n  /etc/group\n字段详解(以\u0026rdquo;:\u0026ldquo;为分隔符)\n组名 : 密码 : GID : 以此组为其附加组的用户列表\n  /etc/gshadow\n       用户管理 #    添加用户\n useradd [options] USERNAME option -u：UID -g：groupname 指定基本组 -G：groupname,... 指定附加组 -c：\u0026quot;COMMENT\u0026quot; -d：指定家目录 -s：指定SHELL路径 -m -k：若家目录不存在，则自动创建 -r：添加系统用户    删除用户\n userdel [options] USERNAME option -r：同时删除用户的家目录    查看用户的帐号属性信息\n id [options] USERNAME option -u：查看UID -g：查看GID -G: 查看所有的GID -n：查看组名 finger USERNAME    修改用户帐号属性\n usermod [options] USERNAME option -u：UID -g：GID -a -g GID：不使用-a选项，会覆盖此前的附加组 -d -m：指定新的家目录，并把之前家目录的文件拷贝到新的家目录中 -c： -s：指定SHELL路径 -L：锁定帐号 -U：解锁帐号    密码管理\n passwd [USERNAME] --stdin：标准输入 -d：删除用户密码    检查用户帐号完整性\n pwck     组管理 #    创建用户组：\n groupadd [option] GROUPNAME -g：GID -r：添加为系统组    修改组的相关属性\n groupmod [option] GROUPNAME -g：GID -n：GRPNAME    删除组\n groupdel GROUPNAME    更改组密码\n gpasswd GROUPNAME     权限管理 #    改变文件属主\n chown USERNAME file,... -R：修改目录及其内部文件的属主 --reference=/path/to/somefile file,... 指定属主与该文件相同 chown USERNAME:GROUPNAME file chown USERNAME.GROUPNAME file    改变属组\n chgrp GROUPNAME file,...    修改文件的权限\n chmod MODE file,... -R： --reference=/path/to/somefile 修改单个用户的权限：u,g,o,a chmod 用户类别+|-MODE file,...     "});index.add({'id':96,'href':'/notes/docs/technology/system/Linux/Lnmp/README/','title':"R E a D M E",'content':"web经典架构 #  Nginx #   Mysql #   PHP #   "});index.add({'id':97,'href':'/notes/docs/technology/tool/Script/script/','title':"Script",'content':"Script #  shell 脚本 #    tomcat系列\n   tomcat服务启动\n   tomcat版本更新\n   tomcat日志分割\n   tomcat应用发布\n   tomcat应用还原\n    zabbix系列\n   server安装\n   agent安装\n     python 脚本 #     PG日志格式更改\n   tcp端口测试\n   ssh登录测试\n   生成随机日志\n  "});index.add({'id':98,'href':'/notes/docs/technology/tool/tcpcopy/','title':"Tcpcopy",'content':"TCPCopy #  TCPCopy是一个流量复制工具。\n 使用场景 #    压力测试\n  模拟实际场景\n  回归测试\n  性能对照\n   架构 #    TCPCopy包含两部分：\n  tcpcopy\n安装在线上服务器上，用于抓取线上的请求包\n  intercept\n安装在辅助服务器上，做一些辅助作业\n   安装使用 #  设备：\nonline server：线上机器(流量导出的机器)\ntarget server：测试机器(流量导入的机器)\nassistant server：辅助机器\n  在target server上添加路由\n $ route add -net CLINET_NET gw ASSISTANG_IP    在assistant server上安装intercept服务\n下载地址： https://github.com/session-replay-tools/intercept/releases\n安装：\n $ cd intercept $ ./configure --prefix=/usr/local/intercept $ make \u0026amp;\u0026amp; make insall  启动：\n $ /usr/local/intercept/sbin/intercept -i eth0 -F tcp and src host TARGET_IP and src port TARGET_PORT -d    在online server安装tcpcopy服务\n下载地址： https://github.com/session-replay-tools/tcpcopy/releases\n安装：\n $ cd tcpcopy $ ./configure --prefix=/usr/local/tcpcopy $ make \u0026amp;\u0026amp; make install  启动\n $ /usr/local/tcpcopy/sbin/tcpcopy -x ONLINE_IP:PORT-TARGET_IP:PORT -s ASSISTAND_IP -c CLIENT_IP -d     "});index.add({'id':99,'href':'/notes/docs/','title':"Docs",'content':""});})();