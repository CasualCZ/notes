# 操作系统思考

### 编译

1. 编译语言和解释语言

  * 编译语言

      程序被翻译成机器语言，之后由硬件执行。

  * 解释语言

      程序被软件解释器读取并执行。

2. 静态类型和动态类型

  * 动态类型

    无需定义变量类型，直到运行时才直到变量类型，解释语言通常支持动态类型。

  * 静态类型

    需定义变量类型，编译语言通常限制为静态类型。

    优点：
    
    * 编译时检查，可以更快找到错误。
    
    * 节省空间
        
          动态语言，变量的名称在程序运行时存储在内存中，并且它们通常可由程序访问。
          编译语言，变量的名称只存在编译时，而不是运行时。
          编译器为每个变量选择一个位置，并记录这些位置作为所编译程序的一部分。变量的位置被称为“地址”。在运行期间，每个变量的值都存储在它的地址处，但变量的名称完全不会存储。

3. 编译过程

  * 预处理

    C是包含"预处理指令"的几种语言之一，它生效于编译之前。例如，`#include` 指令使其他文件的源代码插入到指令所在的位置

  * 解析

      编译器读取源代码，并构建程序的内部表示，称为"抽象语法树(AST)"。这一阶段的错误检查通常为语法错误。

  * 静态检查

      编译器会检查变量和值得类型是否正确，函数调用是否带有正确数量和类型的参数，以及其他。这一阶段的错误检测通常为一些"静态语义"的错误

  * 代码生成

      编译器读取程序的内部表示，并生成机器码或字节码

  * 链接

      如果程序使用了定义在库中的值或函数，编译器需要找到合适的库并包含所需要的代码。

  * 优化

      在这个过程的几个时间点上，编译器可以修改程序来生成运行更快或占用更少空间的代码。

4. 目标代码

  编译后的程序，目标代码并不是可执行代码，但是它可以链接到可执行文件中。

5. 汇编代码

  编译后的程序，它通常为机器代码的可读形式。

6. 预处理

7. 理解错误

***

### 进程

1. 抽象和虚拟化

  * 抽象

      抽象是复杂事物的简单表示。

  * 虚拟化

      一类非常重要的抽象就是虚拟化，它是创建可取的幻象的过程。

2. 隔离

  工程最重要的原则之一就是隔离(lsolation)。

  操作系统最重要的目标之一，就是将每个进程和其他进程隔离，使程序员不必考虑每个可能的交互情况。提供这种隔离的软件对象叫做进程(Porcess)。

  进程是表示运行中程序的软件对象。通常一个对象包含数据，并且提供用于操作数据的方法。

  进程正是包含以下数据的对象：

  * 程序文本，通常是机器语言的指令序列。
  * 程序相关的数据，包括静态数据（编译时分配）和动态数据，后者包括运行时的栈和堆。
  * 任何等等中的IO状态。
  * 程序的硬件状态，包括存储在寄存器中的数据，状态信息，以及程序计数器，它表示当前执行了哪个指令。

  操作系统提供了隔离进程的基本功能：

  * 多任务：大多数操作系统有能力在几乎任何时候中断一个进程，保存它的硬件状态，并且在以后恢复它。
  * 虚拟内存：大多数操作系统会创建幻象，每个进程看似拥有独立内存片并且孤立于其他进程。
  * 设备抽象：运行于同一台计算机的进程共享磁盘、网络接口、显卡和其他硬件。

***

### 虚拟内存
***

### 虚拟内存

1. 简明信息理论

  比特是二进制的数字，也是信息单位。 n个比特可以表示`2 ** b`个值，一个字节是8个比特，所以它可以存储256个值。

2. 内存(Memory)和存储器(Storage)

  当进程处于运行期间，它的多数数据都放在内存中。内存中的数据容易丢失。单位为GiB代表"gibibyte"，相当于`2 ** 30`字节

  如果进程会读写文件，这些文件通常放在存储器中。存储器的数据可用于长时间存储。单位为GB代表"gigabyte"，相当于`10 ** 30`字节

3. 地址空间

  内存中的每个字节都由一个"物理地址"整数所指定，物理地址的集合叫做物理"地址空间"。范围通常为0到N-1，N是内存大小。

  操作系统提供"虚拟内存"，程序处理虚拟地址，范围为0到M-1，M是有效虚拟地址的大小。虚拟地址空间的大小取决于操作系统和硬件。

  * 32位系统

    虚拟地址是32位的，虚拟地址空间的大小是`2 ** 32`个字节，或者4GiB

  * 64位系统

    虚拟地址是64位的，虚拟地址空间的大小是`2 ** 64`个字节，或者是`4 * 1024 ** 6`个字节，16EiB

  当一个程序读写内存中的值时，它使用虚拟地址。硬件在操作系统的帮助下，在访问主存之前将物理地址翻译成虚拟地址。翻译过程在进程层级上完成，所以两个进程访问相同的虚拟地址，他们所映射的物理地址可能不同。
  
  虚拟内存是操作系统隔离进程的一种重要途径。

4. 内存段

  一个运行中进程的数据组织为4个段：

  * text段：包含程序文本，即程序所组成的机器语言指令。靠近内存"底部"，即接近0的地址
  * static段：包含由编译器所分配的变量，包含全局变量和使用`static`声明的局部变量。通常刚好在`text`段上面
  * stack段：包含运行时栈，它由栈帧组成。每个帧包含函数参数、本地变量以及其他。靠近内存顶部，即接近虚拟地址空间的最大地址。在扩张过程中，它向低地址的方向增长。
  * heap段：包含运行时分配的内存块，通常通过调用C标准库函数`malloc`来分配。通常在`static`段的上面，在扩张过程中，它向高地址的方向增长。


5. 静态局部变量

  栈上的局部变量有时称为"自动变量"，它们当函数创建时自动被分配，并且当函数返回时自动被释放。

  C中有另一种局部变量，叫做"静态变量"，它分配在static段上。它在程序启动时初始化，并且在函数调用之间保存它的值。

6. 地址翻译

  虚拟地址(VA)翻译成物理地址(GA)

  大多数处理器提供了内存管理单元(MMU)，位于CPU和主存之间。MMU在VA和PA之间执行快速的翻译。

  * 当程序读写变量时，CPU会得到VA。
  * MMU将VA分成两部分，称为页码和偏移。"页"是一个内存块，页的大小取决于操作系统和硬件，通常为1~4KiB
  * MMU在"页表"里查找页码，然后获取相应的物理页码。之后将物理页码和偏移组合得到PA。
  * PA传递给主存，用于读写指定地址。

***

### 文件和文件系统

“文件系统”将每个文件的名称映射到它的内容。是一种键值对的数据库。
“文件”是一组字节序列。

文件名通常是字符串，并且通常是分层的。这个字符串指定了顶级目录的路径，通过一系列子目录，到达特定的文件。

文件是基于字节的，而持久化存储器是基于块的。操作系统将C标准库中基于字节的文件操作翻译成基于块的存储设备操作。

1. 文件的读取和写入过程：

* 读取

  * 程序使用文件名寻找顶级目录，子目录以及n级目录
  * 找到名为xxx的文件，并且"打开"它以便读取。实际上是创建了一个数据结构料表示将要读取的文件。数据结构还跟踪了文件读取了多少字节，称为“文件位置”。
  * 操作系统检查下个字节是否已经在内存中。如果是的话，读取下一个字节，向前移动文件位置，并返回结果。
  * 如果不在内存中，操作系统产生IO请求来获取下一个块。
  * IO操作完成时，新的数据快回存储在内存中。
  * 当进程关闭文件时，操作系统完成或取消任何等待中的操作，移除内存中的数据，并且释放`OpenFileTableEntry`

* 写入

  * 程序使用文件名寻找文件。如果文件不存在，就会创建新的文件，并向父目录添加条目
  * 操作系统创建`OpenFileTableEntry`，表示这个文件已打开等待写入，并将文件位置设置为0.
  * 程序尝试写入文件的第一个字节。如果文件存在，操作系统需要将第一个块加载到内存中。否则它会在内存中分配新的块，并且在磁盘上请求新的块。
  * 在内存中的块被修改后，可能不会立即复制回磁盘。通常，写到文件中的数据是“被缓冲的”，意思是它存储在内存中，只在至少有一个块需要写入时才写回磁盘。
  * 文件关闭时，任何缓冲的数据都会写到磁盘，并且`OpenFileTableEntry`会被释放。

C标准库提供了文件系统的抽象，将文件名称映射到字节流。这个抽象建立在实际以块组织的存储设备之上。

2. 磁盘性能

操作系统和硬件提供了一些特性用于弥补主存和持久化存储器的性能间隔。

* 块的传输
* 预取
* 缓冲

3. 磁盘元数据

块可以放在磁盘上的任意位置，使用各种数据结构来跟踪这些块。

在UNIX文件系统中，这些数据结构叫做`inode`，它代表“索引节点”(index node)。也叫做“元数据”(数据的数据)

4. 块的分配

操作系统既要跟踪哪些块属于哪个文件，也需要跟踪哪些块可供使用。

块分配系统的目标：

* 速度：块的分配和释放应该很快。
* 最小的空间开销
* 最少的碎片
* 最大的连续性


